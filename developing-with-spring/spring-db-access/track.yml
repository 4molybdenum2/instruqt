challenges:
- assignment: "# Import the code\n\nLet's refresh the code we'll be using. Run the\
    \ following command to clone the sample project:\n\n```\ncd /root/projects &&\
    \ rm -rf rhoar-getting-started && git clone https://github.com/openshift-katacoda/rhoar-getting-started\
    \ && cd rhoar-getting-started/spring/spring-db-access\n```\n\n# Review the base\
    \ structure of the application\n\nFor your convenience, this scenario has been\
    \ created with a base project using the Java programming language and the Apache\
    \ Maven build tool. Initially the project contains a couple web-oriented files\
    \ which are out of scope for this module. See the Spring Rest Services module\
    \ for more details. These files are in place to give a graphical view of the Database\
    \ content. \n\nAs you review the content you will notice that there are a couple\
    \ **TODO** comments. **Do not remove them!** These comments are used as markers\
    \ for later exercises in this scenario. \n\nIn the next section we will add the\
    \ dependencies and write the class files necessary to run the application.\n\n\
    # Inspect Java runtime\n\nAn appropriate Java runtime has been installed for you.\
    \ Ensure you can use it by running this command:\n\n```\njava --version\n```\n\
    \nThe command should report the version in use, for example (the versions and\
    \ dates may be slightly different than the below example):\n\n```console\nopenjdk\
    \ 11.0.10 2021-01-19\nOpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)\n\
    OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)\n```\n\nIf\
    \ the command fails, wait a few moments and try again (it is installed in a background\
    \ process and make take a few moments depending on system load)."
  difficulty: basic
  slug: 01-review-the-initial-project
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 1
  type: challenge
- assignment: "# Read content from a database\n\nIn Step 1 you learned how to get\
    \ started with our project. In this step, we will add functionality for our Fruit\
    \ basket application to display content from the database.\n\n**1. Adding JPA\
    \ (Hibernate) to the application**\n\nSince our application will need to access\
    \ a database to retrieve and store fruit entries we need to add a Database Connection\
    \ library. One such implementation in Spring is the Spring Data JPA project, which\
    \ contains the Java Persistence APIs (JPA) and a JPA implementation - Hibernate.\
    \ Hibernate has been tested and verified as part of the Red Hat Runtimes, so we\
    \ are going to use it here. Spring Boot has full knowledge of these libraries\
    \ as well so we get to take advantage of Spring Boot's auto-configuration with\
    \ these libraries as well!\n\nTo add Spring Data + JPA and Hibernate to our project\
    \ all we have to do is to add the following line in ``pom.xml``{{open}}\n\n<pre\
    \ class=\"file\" data-filename=\"pom.xml\" data-target=\"insert\" data-marker=\"\
    <!-- TODO: Add JPA dependency here -->\">\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\
    \      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n   \
    \ &lt;/dependency&gt;\n</pre>\n\nWe also need a Database to actually interact\
    \ with. When running locally or when running tests an in-memory Database is often\
    \ used over connection to an external Database because its lifecycle can be managed\
    \ by Spring and we don't have to worry about outages impacting our local development.\
    \ H2 is a small in-memory database that is perfect for testing but is not recommended\
    \ for production environments. To add H2 add the following dependency at the comment\
    \ `<!-- TODO: Add H2 database dependency here -->` in the local profile.\n\n<pre\
    \ class=\"file\" data-filename=\"pom.xml\" data-target=\"insert\" data-marker=\"\
    <!-- TODO: Add H2 database dependency here -->\">\n    &lt;dependency&gt;\n  \
    \    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n      &lt;artifactId&gt;h2&lt;/artifactId&gt;\n\
    \      &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;/dependency&gt;\n</pre>\n\n\
    If Spring Boot sees a database like H2 on the classpath it will automatically\
    \ configure an in-memory one for us as well as all the connection Beans necessary\
    \ to connect to it. We've chosen to override these settings in the ``src/main/resources/application-local.properties``{{open}}\
    \ file to demonstrate that you can interact with Spring Boot's auto-configuration\
    \ quite easily. \n\n**2. Create an Entity class**\n\nWe are going to implement\
    \ an Entity class that represents a Fruit. This class is used to map our object\
    \ to a database schema.\n\nFirst, we need to create the java class file. For that,\
    \ you need to click on the following link which opens the skeletal class file\
    \ in the editor: ``src/main/java/com/example/service/Fruit.java``{{open}}\n\n\
    Then, copy the below content into the file (or use the `Copy to Editor` button):\n\
    \n<pre class=\"file\" data-filename=\"src/main/java/com/example/service/Fruit.java\"\
    \ data-target=\"replace\">\npackage com.example.service;\n\nimport javax.persistence.Entity;\n\
    import javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\n\
    import javax.persistence.Id;\n\n@Entity\npublic class Fruit {\n\n    @Id\n   \
    \ @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n\
    \    private String name;\n\n    public Fruit() {\n    }\n\n    public Fruit(String\
    \ type) {\n        this.name = type;\n    }\n\n    public Long getId() {\n   \
    \     return id;\n    }\n\n    public void setId(Long id) {\n        this.id =\
    \ id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n\
    \    public void setName(String name) {\n        this.name = name;\n    }\n}\n\
    </pre>\n\nThe `@Entity` annotation marks the object as a persistable Entity for\
    \ Spring Data. The `@Id` and `@GeneratedValue` annotations are JPA annotations\
    \ which mark the the `id` field as the database ID field which has an auto-generated\
    \ value. Spring provides the code which makes these annotations work behind the\
    \ scenes.\n\n**3.Create a repository class for our content**\n\nThe repository\
    \ should provide methods for inserting, updating, reading, and deleting Fruits\
    \ from the database. We are going to use Spring Data for this which already provides\
    \ us with a lot of the boilerplate code, so all we have to do is to add an interface\
    \ that extends the `CrudRepository<T, I>` interface provided by Spring Data.\n\
    \nFirst, we need to fill out the skeltal java class file. For that, you need to\
    \ click on the following link which opens the file in the editor: ``src/main/java/com/example/service/FruitRepository.java``{{open}}\n\
    \nThen, copy the below content into the file (or use the `Copy to Editor` button):\n\
    \n<pre class=\"file\" data-filename=\"src/main/java/com/example/service/FruitRepository.java\"\
    \ data-target=\"replace\">\npackage com.example.service;\n\nimport org.springframework.data.jpa.repository.Query;\n\
    import org.springframework.data.repository.CrudRepository;\nimport org.springframework.stereotype.Repository;\n\
    \nimport java.util.List;\n\n@Repository\npublic interface FruitRepository extends\
    \ CrudRepository&lt;Fruit, Long&gt; {\n// TODO query methods\n}\n</pre>\n\n**4.\
    \ Populate the database with initial content**\n\nTo pre-populate the database\
    \ with content, Hibernate offers a nifty feature where we can provide an SQL file\
    \ that populates the content.\n\nFirst, we need to create the SQL file. For that,\
    \ you need to click on the following link which opens the empty file in the editor:\
    \ ``src/main/resources/import.sql``{{open}}\n\nThen, copy the below content into\
    \ the file (or use the `Copy to Editor` button):\n\n<pre class=\"file\" data-filename=\"\
    src/main/resources/import.sql\" data-target=\"replace\">\ninsert into fruit (name)\
    \ values ('Cherry');\ninsert into fruit (name) values ('Apple');\ninsert into\
    \ fruit (name) values ('Banana');\n</pre>\n\n**5. Test and Verify**\nTo verify\
    \ that we can use the `FruitRepository` for retrieving and storing Fruit objects\
    \ we have created a JUnit Test Class at ``src/test/java/com/example/service/DatabaseTest.java``{{open}}\n\
    \nTake a bit of time and review the tests. The `testGetAll` test will return all\
    \ fruits in the repository, which should be three because of the content in `import.sql`.\
    \ The `getOne` test will retrieve the fruit with ID 1 (e.g., the Cherry) and then\
    \ check that it's not null. The `getWrongId` checks that if we try to retrieve\
    \ a fruit id that doesn't exist and check that fruitRepository returns null.\n\
    \nWe can now test that our `FruitRepository` can connect to the data source, retrieve\
    \ data and \nRun the application by executing the below command:\n\n``mvn verify``{{execute\
    \ interrupt}}\n\nIn the console you should now see the following (if the output\
    \ is too noisy the first time around because of downloads simply run the command\
    \ again):\n\n```\nResults :\n\nTests run: 5, Failures: 0, Errors: 0, Skipped:\
    \ 0\n```\n\n>**NOTE:** As a reminder: the configuration for database connectivity\
    \ is found in the application properties files in `src/main/resources/` since\
    \ we chose to override the Spring Boot defaults. For local we use the `application-local.properties`\
    \ file. On OpenShift we use the `application-openshift.properties` file.\n\n**6.\
    \ Review The Controller**\n\nTo see how this repository could be used in a web\
    \ application we're going to quickly review the FruitController file. Open ``src/main/java/com/example/service/FruitController.java``{{open}}\
    \ in your editor.\n\nIn order to use our FruitRepository we must first autowire\
    \ one in our constructor:\n\n```java\npublic FruitController(FruitRepository repository)\
    \ {\n    this.repository = repository;\n}\n```\n\nSince Repositories are a managed\
    \ Bean in Spring we have to tell Spring to inject an instance into our Controller\
    \ for use. We use Constructor Autowiring as per the suggestion of the Spring Team\
    \ since it is considered best practice and allows easier mock injecting in tests.\n\
    \nIf we are fetching all records from the database we use the aforementioned `repository.findAll()`\
    \ method. To delete we have `repository.delete(id)`, to save a new entry we have\
    \ `repository.save(fruit)`, and so on. All these methods reside on the CrudRepository\
    \ interface which is automatically implemented by Spring.\n\n>**NOTE:** The usual\
    \ input validations have been omitted from this class for brevity's sake. Always\
    \ validate and sanitize input coming from the client!\n\n**7. Query Methods**\n\
    \nThe methods provided by CrudRepository are nice when we are dealing directly\
    \ with IDs but sometimes we don't have that information. Let's say, for example,\
    \ we have a search box that allows users to search by Fruit Name. We currently\
    \ do not support that functionality without using a `findAll()` and then filtering\
    \ the results in the application. Not a good idea for large datasets.\n\nFortunately\
    \ there exists within the JPA specification a section on `Query Methods`. Query\
    \ methods are methods on Repositories that follow a specific naming pattern. These\
    \ methods can then be turned into implementation code by JPA providers for running\
    \ actual queries.\n\nLet's re-open the FruitRepository class file in the editor:\
    \ ``src/main/java/com/example/service/FruitRepository.java``{{open}} and add the\
    \ following code at the TODO line (or use the `Copy to Editor` button):\n\n<pre\
    \ class=\"file\" data-filename=\"src/test/java/com/example/service/FruitRepository.java\"\
    \ data-target=\"insert\" data-marker=\"// TODO query methods\">\n    List&lt;Fruit&gt;\
    \ findByName(String name);\n\n    default List&lt;Fruit&gt; findAllFruitsByName(String\
    \ name) {\n        return findByName(name);\n    }\n\n    @Query(\"select f from\
    \ Fruit f where f.name like %?1\")\n    List&lt;Fruit&gt; findByNameLike(String\
    \ name);\n</pre>\n\nThe first method `findByName(String name)` is a standard JPA\
    \ _Query Method_. The format of this method is `findBy` followed by the field\
    \ we are querying on for our Fruit object. For the `name` field we use the same\
    \ name. Note that the field name is capitalized to follow the standard Java _camelCase_\
    \ format. \n\nThe format of these methods can get pretty complex but here we're\
    \ only referring to the `name` field of our `Fruit` model so the method name is\
    \ pretty short. For a more in depth guide to Query Methods see [this](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods)\
    \ article.\n\nThe second method demonstrates _default methods_ which were introduced\
    \ in Java 8. This allows us to provide a method definition for an interface method.\
    \ In this case we've created an alias for the `findByName()` method which simply\
    \ delegates to the JPA Query Method. This technique is particularly useful when\
    \ the Query Methods get very complex and long as it allows us to define more readable\
    \ repository methods that delegate to their more complex counterpart. We can also\
    \ aggregate operations in this way.\n\nThe last method is an example of the `@Query`\
    \ annotation which allows you to provide an actual SQL Query to execute. Note,\
    \ however, that the syntax is a little different. This is actually a dialect called\
    \ JPQL which looks like ANSI SQL but with a few differences. You can, however,\
    \ use native queries by adding the `nativeQuery=true` argument to the annotation.\
    \ Be aware that this approach can cause tight coupling between your code and your\
    \ database if you use database-specific extensions that won't be caught until\
    \ runtime. This is, however, particularly useful for complex queries that are\
    \ better suited for plain native SQL.\n\n**8. Verify the application**\n\nTo verify\
    \ that the application actually works now we need to actually run the application.\
    \ Run the application by executing the following command ```\nmvn spring-boot:run\n\
    ```\n\nNext, click on the **Local Web Browser** tab in the console frame of this\
    \ browser window which will open another tab or window of your browser pointing\
    \ to port 8080 on your client. Or use [this](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com)\
    \ link.\n\nYou should now see an HTML page with an `Add a Fruit` textbox on the\
    \ left and a `Fruits List` view on the right with the three fruits we pre-populated\
    \ with the `import.sql` file. Adding a new fruit name into the textbox and clicking\
    \ `Save` should insert the new Fruit name into the right-hand list. Clicking on\
    \ the `Remove` buttons should also work as expected.\n\n**9. Stop the application**\n\
    \nBefore moving on, click in the terminal window and then press <kbd>CTRL</kbd>+<kbd>C</kbd>\
    \ to stop the running application!\n\n## Congratulations\n\nYou have now learned\
    \ how to create and test a data repository that can create, read, update and delete\
    \ content from a database. We have so far been testing this with an in-memory\
    \ database, but later we will replace this with a full blow SQL server running\
    \ on OpenShift, but first, we should create REST services that the web page can\
    \ use to update content.\n"
  difficulty: basic
  slug: 02-read-content-from-a-database
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 2
  type: challenge
- assignment: "# Deploy to OpenShift\n\nFor running locally the H2 Database has been\
    \ a good choice, but when we now move into a container platform we want to use\
    \ a more production-like database, and for that, we are going to use PostgreSQL.\
    \ \n\nBefore we deploy the application to OpenShift and verify that it runs correctly,\
    \ there are a couple of things we have do. We need to add a driver for the PostgreSQL\
    \ database that we are going to use, and we also need to add health checks so\
    \ that OpenShift correctly can detect if our application is working. \n\n**1.\
    \ Create a project**\n\nLet's first create a new project\n\n```\noc new-project\
    \ dev --display-name=\"Dev - Spring Boot App\"\n```\n\n**2. Create the database**\n\
    \nSince this is your own personal project you need to create a database instance\
    \ that your application can connect to. In a shared environment this would typically\
    \ be provided for you, that's why we are not deploying this as part of your application.\
    \ It's however very simple to do that in OpenShift. All you need to do is to execute\
    \ the below command in the console.\n\n``oc new-app -e POSTGRESQL_USER=dev \\\n\
    \             -e POSTGRESQL_PASSWORD=secret \\\n             -e POSTGRESQL_DATABASE=my_data\
    \ \\\n             openshift/postgresql:12-el8 \\\n             --name=my-database``{{execute}}\n\
    \nThis command creates a new deployable Postgres instance using the OpenShift\
    \ Postgresql image named `my-database`. This step may take a minute or two. We\
    \ can wait for it to complete by running the following command:\n\n```\noc rollout\
    \ status -w deployment/my-database\n```\n\n**3. Review Database configuration**\n\
    \nTake some time and review the ``src/main/jkube/deployment.yml``{{open}}.\n\n\
    As you can see that file specifies a couple of elements that are needed for our\
    \ deployment. It also uses the username and password from a Kubernetes Secret.\
    \ For this environment we are providing the secret in this file ``src/main/jkube/credentials-secret.yml``{{open}},\
    \ however in a production environment this would likely be provided to you by\
    \ the Ops team.\n\nNow, review the ``src/main/resources/application-openshift.properties``{{open}}\n\
    \nIn this file we are using the configuration from the `deployment.yml` to read\
    \ the username, password, and other connection details. \n\n**4. Add the PostgreSQL\
    \ database driver**\n\nSo far our application has only used the H2 embedded Database.\
    \ We now need to add a dependency for the PostgreSQL driver. We do that by adding\
    \ a runtime dependency under the `openshift` profile in the ``pom.xml``{{open}}\
    \ file.\n\n<pre class=\"file\" data-filename=\"pom.xml\" data-target=\"insert\"\
    \ data-marker=\"<!-- TODO: Add PostgreSQL database dependency here -->\">\n  \
    \      &lt;dependency&gt;\n          &lt;groupId&gt;org.postgresql&lt;/groupId&gt;\n\
    \          &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n          &lt;scope&gt;runtime&lt;/scope&gt;\n\
    \        &lt;/dependency&gt;\n</pre>\n\n\n**5. Add a health check**\n\nWe also\
    \ need a health check so that OpenShift can detect when our application is responding\
    \ correctly. Spring Boot provides a nice feature for this called Actuator, which\
    \ exposes health data under the path `/health`. All we need to do is to add the\
    \ following dependency to ``pom.xml``{{open}} at the **TODO** comment..\n\n<pre\
    \ class=\"file\" data-filename=\"pom.xml\" data-target=\"insert\" data-marker=\"\
    <!-- TODO: Add Actuator dependency here -->\">\n    &lt;dependency&gt;\n     \
    \ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\
    \    &lt;/dependency&gt;\n</pre>\n\n**6. Deploy the application to OpenShift**\n\
    \nRun the following command to deploy the application to OpenShift\n\n```\nmvn\
    \ oc:deploy -Popenshift -DskipTests\n```\n\nThis step may take some time to do\
    \ the Maven build and the OpenShift deployment. After the build completes you\
    \ can verify that everything is started by running the following command:\n\n\
    ```\noc rollout status dc/spring-data-jpa-training\n```\n\nThen either go to the\
    \ OpenShift web console and click on the route or click [here](http://spring-data-jpa-training-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/).\n\
    \nMake sure that you can add and remove fruits using the web application.\n\n\
    # Open the solution in an IDE in the Cloud!\nWant to continue exploring this solution\
    \ on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview)\
    \ IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox).\
    \ [Click here](https://workspaces.openshift.com) to login or to register if you\
    \ are a new user. This free service expires after 30 days, but you can always\
    \ enable a new free 30-day subscription.\n\nOnce logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/spring/spring-db-access/devfile.yaml)\
    \ to open the solution for this project in the cloud IDE. While loading, if it\
    \ asks you to update or install any plugins, you can say no.\n\n# Fork the source\
    \ code to your own GitHub!\nWant to experiment more with the solution code you\
    \ just worked with? If so, you can fork the repository containing the solution\
    \ to your own GitHub repository by clicking on the following command to execute\
    \ it:\n\n`/root/projects/forkrepo.sh`{{execute T1}}\n- Make sure to follow the\
    \ prompts. An error saying `Failed opening a web browser at https://github.com/login/device\
    \ exit status 127` is expected.\n- [Click here](https://github.com/login/device)\
    \ to open a new browser tab to GitHub and paste in the code you were presented\
    \ with and you copied.\n- Once done with the GitHub authorization in the browser,\
    \ close the browser tab and return to the console and press `Enter` to complete\
    \ the authentication process.\n- If asked to clone the fork, press `n` and then\
    \ `Enter`.\n- If asked to confirm logout, press `y` and the `Enter`.\n\n   > **NOTE:**\
    \ This process uses the [GitHub CLI](https://cli.github.com) to authenticate with\
    \ GitHub. The learn.openshift.com site is not requesting nor will have access\
    \ to your GitHub credentials.\n\nAfter completing these steps the `rhoar-getting-started`\
    \ repo will be forked in your own GitHub account. On the `solution` branch in\
    \ the repo, the `spring-db-access` project inside the `spring` folder contains\
    \ the completed solution for this scenario.\n\n## Congratulations\n\nYou have\
    \ now learned how to deploy a Spring Boot application to OpenShift Container Platform\
    \ with a PostgreSQL database. Click Summary for more details and suggested next\
    \ steps.\n"
  difficulty: basic
  slug: 03-deploy-to-openshift
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 3
  type: challenge
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: openshift
private: false
published: true
skipping_enabled: false
slug: spring-db-access
tags:
- openshift
title: Spring Data with JPA/Hibernate
type: track
