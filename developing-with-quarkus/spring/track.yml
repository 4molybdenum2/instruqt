challenges:
- assignment: "# Inspect Java runtime\n\nAn appropriate Java runtime has been installed\
    \ for you. Ensure you can use it by running this command:\n\n> If the command\
    \ fails, wait a few moments and try again (it is installed in a background process\
    \ and make take a few moments depending on system load).\n\n```\n$JAVA_HOME/bin/java\
    \ --version\n```\n\nThe command should report the version in use, for example\
    \ (the versions and dates may be slightly different than the below example):\n\
    \n```console\nopenjdk 11.0.10 2021-01-19\nOpenJDK Runtime Environment AdoptOpenJDK\
    \ (build 11.0.10+9)\nOpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed\
    \ mode)\n```\n\n## Create basic project\n\nLet's create the basic Quarkus _Hello\
    \ World_ application and include the necessary spring extensions. Click this command\
    \ to create the project:\n\n`cd /root/projects/quarkus &&\n mvn io.quarkus:quarkus-maven-plugin:2.0.0.Final:create\
    \ \\\n    -DprojectGroupId=org.acme \\\n    -DprojectArtifactId=fruit-taster \\\
    \n    -Dextensions=\"spring-data-jpa,spring-web,spring-di,jdbc-postgres, jdbc-h2\"\
    `{{execute T1}}\n\nThis will use the Quarkus Maven Plugin and generate a basic\
    \ Maven project for you in the `fruit-taster` subdirectory and include the following\
    \ extensions to enable Spring annotations and APIs:\n\n* **spring-data-jpa** -\
    \ Adds Spring Data annotations like `@CrudRepository` allowing integration with\
    \ database-backed JPA repositories\n* **spring-web** - Adds Spring Web annotations\
    \ like `@RestController`, `@RequestMapping`, `@PathVariable`, `@GetMapping`, etc\n\
    * **spring-di** - Adds Spring DI annotations like `@Autowired`, `@Configuration`,\
    \ `@Component`, etc\n* **jdbc-postgres** - Driver for Postgresql database. Note\
    \ this is the `jdbc` variant. Reactive programmers may be interested in the [Reactive\
    \ Postgres Client](https://quarkus.io/guides/reactive-postgres-client).\n* **jdbc-h2**\
    \ - We also use the h2 database for local development\n\n## Start the app\n\n\
    First, switch to the directory in which the app was built:\n\n```\ncd /root/projects/quarkus/fruit-taster\n\
    ```\n\nLet's begin Live Coding. Click on the following command to start the app\
    \ in _Live Coding_ mode:\n\n```\nmvn quarkus:dev -Dquarkus.http.host=0.0.0.0\n\
    ```\n\nYou should see:\n\n```console\n__  ____  __  _____   ___  __ ____  ______\n\
    \ --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n -/ /_/ / /_/ / __ |/ , _/ ,< /\
    \ /_/ /\\ \\\n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\nINFO  [io.quarkus]\
    \ (Quarkus Main Thread) fruit-taster 1.0.0-SNAPSHOT on JVM (powered by Quarkus\
    \ xx.xx.xx.Final) started in xxxs. Listening on: http://0.0.0.0:8080\nINFO  [io.quarkus]\
    \ (Quarkus Main Thread) Profile dev activated. Live Coding activated.\nINFO  [io.quarkus]\
    \ (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache,\
    \ jdbc-h2, jdbc-postgresql, narayana-jta, resteasy, resteasy-jackson, smallrye-context-propagation,\
    \ spring-data-jpa, spring-di, spring-web]\n\n--\nTests paused, press [r] to resume,\
    \ [h] for more options>\n```\n> The first time you build the app, new dependencies\
    \ may be downloaded via maven. This should only happen once, after that things\
    \ will go even faster.\n\nTest that the app is running by accessing the simple\
    \ `hello` endpoint:\n\n`cd /root/projects/quarkus/fruit-taster && \\\n  curl http://localhost:8080/greeting`{{execute\
    \ T2}}\n\n> You may need to click this command again in case it doesn't execute\
    \ properly on first click\n\nyou should see\n\n```console\nHello Spring\n```\n\
    \nThis app doesn't use any Spring annotations yet. You'll _live code_ those in\
    \ the next few steps while the app continues to run."
  difficulty: basic
  slug: 01-create-project
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 1
  type: challenge
- assignment: "# Create Spring Data Repository\n\nThe Spring Data repository abstraction\
    \ simplifies dealing with data models by reducing the amount of boilerplate code\
    \ required to implement data access layers for various persistence stores (such\
    \ as JPA). `@Repository` and its sub-interfaces like `@CrudRepository` are the\
    \ [central concept in Spring Data](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.core-concepts)\
    \ which is a marker interface to provide data manipulation functionality for the\
    \ entity class that is being managed. When the application starts, Quarkus configures\
    \ the required persistence technologies and provides an implementation for the\
    \ interfaces used.\n\nFirst, we need a data model.\n\n## Create Model\n\nClick\
    \ here to create and open a new file for our Remodelpository: `fruit-taster/src/main/java/org/acme/Fruit.java`{{open}}.\n\
    \nClick **Copy to Editor** to add the code:\n\n<pre class=\"file\" data-filename=\"\
    ./fruit-taster/src/main/java/org/acme/Fruit.java\" data-target=\"replace\">\n\
    package org.acme;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\n\
    import javax.persistence.Id;\n\n@Entity\npublic class Fruit {\n\n    @Id\n   \
    \ @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    private\
    \ String color;\n\n\n    public Fruit() {\n    }\n\n    public Fruit(String name,\
    \ String color) {\n        this.name = name;\n        this.color = color;\n  \
    \  }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void\
    \ setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName()\
    \ {\n        return name;\n    }\n\n    public void setName(String name) {\n \
    \       this.name = name;\n    }\n\n    public String getColor() {\n        return\
    \ color;\n    }\n\n    public void setColor(String color) {\n        this.color\
    \ = color;\n    }\n}\n</pre>\n\nThis is a simple POJO representing a Fruit, with\
    \ a name and color.\n\n## Create Spring Data Repository\n\nNext, click here to\
    \ create and open a new file for our Repository: `fruit-taster/src/main/java/org/acme/FruitRepository.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the repository:\n\n<pre class=\"\
    file\" data-filename=\"./fruit-taster/src/main/java/org/acme/FruitRepository.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport org.springframework.data.repository.CrudRepository;\n\
    \nimport java.util.List;\n\npublic interface FruitRepository extends CrudRepository&lt;Fruit,\
    \ Long&gt; {\n\n    List&lt;Fruit&gt; findByColor(String color);\n\n}\n</pre>\n\
    \nNote that by extending Spring's `CrudRepository` interface you'll automatically\
    \ get a complete set of methods to manipulate the entity (e.g. `count()`, `findAll()`,\
    \ `delete()` and others).\n\n## Create sample data\n\nFinally, we need some sample\
    \ data to work with. Click here to create and open a new file to hold our sample\
    \ data: `fruit-taster/src/main/resources/import.sql`{{open}}.\n\nClick **Copy\
    \ to Editor** to create add the sample data which will be used to populate our\
    \ database when the app runs:\n\n<pre class=\"file\" data-filename=\"./fruit-taster/src/main/resources/import.sql\"\
    \ data-target=\"replace\">\nINSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'),\
    \ 'cherry', 'red');\nINSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'),\
    \ 'orange', 'orange');\nINSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'),\
    \ 'banana', 'yellow');\nINSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'),\
    \ 'avocado', 'green');\nINSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'),\
    \ 'strawberry', 'red');\n</pre>\n\n## Configure Quarkus\n\nWe need to configure\
    \ our app to define database connection settings. Click: `fruit-taster/src/main/resources/application.properties`{{open}}\
    \ to open this file. This file contains Quarkus configuration.\n\nClick **Copy\
    \ to Editor** to add the following values to the `application.properties` file:\n\
    \n<pre class=\"file\" data-filename=\"./fruit-taster/src/main/resources/application.properties\"\
    \ data-target=\"replace\">\nquarkus.datasource.db-kind=h2\nquarkus.datasource.jdbc.url=jdbc:h2:mem:rest-crud\n\
    quarkus.hibernate-orm.database.generation=drop-and-create\nquarkus.hibernate-orm.log.sql=true\n\
    quarkus.hibernate-orm.sql-load-script=import.sql\n</pre>\n\nThat\u2019s it! Now\
    \ you have a database, domain model (`Fruit`) and a repository (`FruitRepository`)\
    \ to retrieve the domain model, and some sample data.\n\n> **NOTE**\n> Although\
    \ we are using `import.sql` to initialize our database in our app, you shouldn't\
    \ use this in production. Instead, review [suggested uses of Hibernate ORM in\
    \ production](https://quarkus.io/guides/hibernate-orm#hibernate-orm-in-production-mode).\n\
    \nNext, we'll create some injectable Spring Beans that will give us access to\
    \ the data using the Spring DI annotations."
  difficulty: basic
  slug: 02-create-data
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 2
  type: challenge
- assignment: "# Spring DI in Quarkus\n\nWhile you are encouraged to use CDI annotations\
    \ for injection, Quarkus provides a compatibility layer for Spring dependency\
    \ injection in the form of the `spring-di` extension.\n\nThis step explains how\
    \ your Quarkus application can leverage the well known Dependency Injection annotations\
    \ included in the Spring Framework.\n\nLet\u2019s proceed to create some beans\
    \ using various Spring annotations.\n\n## Create Functional Interface\n\nFirst\
    \ we will create a `StringFunction` interface that some our beans will implement\
    \ and which will be injected into another bean later on. This _Functional Interface_\
    \ provide target types for lambda expressions and method references we'll define.\n\
    \n> Functional Interfaces are part of the base Java platform, and are not Spring-specific.\n\
    \nClick here to create and open a new file for our interface: `fruit-taster/src/main/java/org/acme/StringFunction.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the interface:\n\n<pre class=\"\
    file\" data-filename=\"./fruit-taster/src/main/java/org/acme/StringFunction.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport java.util.function.Function;\n\
    \npublic interface StringFunction extends Function&lt;String, String&gt; {\n\n\
    }\n</pre>\n\nWith the interface in place, we will add an `AppConfiguration` class\
    \ which will use the Spring\u2019s Java Config style for defining a bean. It will\
    \ be used to create a `StringFunction` bean that will capitalize the text passed\
    \ as parameter.\n\nClick here to create and open a new file for our configuration:\
    \ `fruit-taster/src/main/java/org/acme/AppConfiguration.java`{{open}}.\n\nClick\
    \ **Copy to Editor** to create the code for the interface:\n\n<pre class=\"file\"\
    \ data-filename=\"./fruit-taster/src/main/java/org/acme/AppConfiguration.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport org.springframework.context.annotation.Bean;\n\
    import org.springframework.context.annotation.Configuration;\n\n@Configuration\n\
    public class AppConfiguration {\n\n    @Bean(name = \"capitalizeFunction\")\n\
    \    public StringFunction capitalizer() {\n        return String::toUpperCase;\n\
    \    }\n}\n</pre>\n\n## Create Functions\n\nNow we define another bean that will\
    \ implement `StringFunction` using Spring\u2019s _stereotype annotation_ style.\
    \ This bean will effectively be a no-op bean that simply returns the input as\
    \ is.\n\nClick here to create and open a new file for our bean: `fruit-taster/src/main/java/org/acme/NoOpSingleStringFunction.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the interface:\n\n<pre class=\"\
    file\" data-filename=\"./fruit-taster/src/main/java/org/acme/NoOpSingleStringFunction.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport org.springframework.stereotype.Component;\n\
    \n@Component(\"noopFunction\")\npublic class NoOpSingleStringFunction implements\
    \ StringFunction {\n\n    @Override\n    public String apply(String s) {\n   \
    \     return s;\n    }\n}\n</pre>\n\n## Add injectable configuration\n\nQuarkus\
    \ also provides support for injecting configuration values using Spring\u2019\
    s `@Value` annotation. To see that in action, click **Copy to Editor** to add\
    \ a new configuration parameter to our application which we'll use to add a little\
    \ flavor to our app:\n\n<pre class=\"file\" data-filename=\"./fruit-taster/src/main/resources/application.properties\"\
    \ data-target=\"append\">\ntaste.message = tastes great\n</pre>\n\nWe'll also\
    \ need a new Spring Bean to use this configuration! Click here to create and open\
    \ a new file for our configuration: `fruit-taster/src/main/java/org/acme/MessageProducer.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the interface:\n\n<pre class=\"\
    file\" data-filename=\"./fruit-taster/src/main/java/org/acme/MessageProducer.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport org.springframework.beans.factory.annotation.Value;\n\
    import org.springframework.stereotype.Service;\n\n@Service\npublic class MessageProducer\
    \ {\n\n    @Value(\"${taste.message}\")\n    String message;\n\n    public String\
    \ getTaste() {\n        return message;\n    }\n}\n</pre>\n\n## Tie them all together\n\
    \nThe final bean we will create ties together all the previous beans.\n\nClick\
    \ here to create and open a new file for our configuration: `fruit-taster/src/main/java/org/acme/TasterBean.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the bean:\n\n<pre class=\"file\"\
    \ data-filename=\"./fruit-taster/src/main/java/org/acme/TasterBean.java\" data-target=\"\
    replace\">\npackage org.acme;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\
    import org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.beans.factory.annotation.Value;\n\
    import org.springframework.stereotype.Component;\n\n@Component\npublic class TasterBean\
    \ {\n\n    private final MessageProducer messageProducer;\n\n    @Autowired\n\
    \    @Qualifier(\"noopFunction\")\n    StringFunction noopStringFunction;\n\n\
    \    @Autowired\n    @Qualifier(\"capitalizeFunction\")\n    StringFunction capitalizerStringFunction;\n\
    \n    @Value(\"${taste.suffix:!}\")\n    String suffix;\n\n    public TasterBean(MessageProducer\
    \ messageProducer) {\n        this.messageProducer = messageProducer;\n    }\n\
    \n    public String taste(String fruitName) {\n        final String initialValue\
    \ = fruitName + \": \" + messageProducer.getTaste() + \" \" + suffix;\n      \
    \  return noopStringFunction.andThen(capitalizerStringFunction).apply(initialValue);\n\
    \    }\n}\n</pre>\n\nIn the code above, we see that both field injection and constructor\
    \ injection are being used (note that constructor injection does not need the\
    \ `@Autowired` annotation since there is a single constructor). Furthermore, the\
    \ `@Value` annotation on `suffix` has also a default value defined, which in this\
    \ case will be used since we have not defined `taste.suffix` in `application.properties`.\n\
    \nThis new `TasterBean` has a method `taste()` which will report how each fruit\
    \ tastes. It also uses our functions `noopStringFunction` and `capitalizerStringFunction`\
    \ that we've injected via `@Autowired` to both do nothing and also transform the\
    \ result INTO ALL CAPS.\n\nWith our data model, repository, and accessor beans\
    \ in place, let's move to the final step where we'll expose our fruits to the\
    \ outside world via Spring Web annotations.\n"
  difficulty: basic
  slug: 03-create-beans
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 3
  type: challenge
- assignment: "# Using Spring Web Annotations in Quarkus\n\nWhile you are encouraged\
    \ to use JAX-RS annotation for defining REST endpoints, Quarkus provides a compatibility\
    \ layer for Spring Web in the form of the `spring-web` extension.\n\nThis step\
    \ shows how your Quarkus application can leverage the well known Spring Web annotations\
    \ to define RESTful services.\n\n## Create Controllers\n\nClick here to create\
    \ and open a new file for our basic controller for accessing Fruits: `fruit-taster/src/main/java/org/acme/FruitController.java`{{open}}.\n\
    \nClick **Copy to Editor** to create the code for the controller:\n\n<pre class=\"\
    file\" data-filename=\"./fruit-taster/src/main/java/org/acme/FruitController.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport java.util.List;\nimport\
    \ java.util.Optional;\n\nimport org.springframework.web.bind.annotation.DeleteMapping;\n\
    import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\
    import org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.PathVariable;\n\
    import org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\n\
    \n@RestController\n@RequestMapping(\"/fruits\")\npublic class FruitController\
    \ {\n\n    private final FruitRepository fruitRepository;\n\n    public FruitController(FruitRepository\
    \ fruitRepository) {\n        this.fruitRepository = fruitRepository;\n    }\n\
    \n    @GetMapping(produces = \"application/json\")\n    public Iterable&lt;Fruit&gt;\
    \ findAll() {\n        return fruitRepository.findAll();\n    }\n\n\n    @DeleteMapping(\"\
    /{id}\")\n    public void delete(@PathVariable(name = \"id\") long id) {\n   \
    \     fruitRepository.deleteById(id);\n    }\n\n    @PostMapping(path = \"/name/{name}/color/{color}\"\
    , produces = \"application/json\")\n    public Fruit create(@PathVariable(name\
    \ = \"name\") String name, @PathVariable(name = \"color\") String color) {\n \
    \       return fruitRepository.save(new Fruit(name, color));\n    }\n\n    @PutMapping(path\
    \ = \"/id/{id}/color/{color}\", produces = \"application/json\")\n    public Fruit\
    \ changeColor(@PathVariable(name = \"id\") Long id, @PathVariable(name = \"color\"\
    ) String color) {\n        Optional&lt;Fruit&gt; optional = fruitRepository.findById(id);\n\
    \        if (optional.isPresent()) {\n            Fruit fruit = optional.get();\n\
    \            fruit.setColor(color);\n            return fruitRepository.save(fruit);\n\
    \        }\n\n        throw new IllegalArgumentException(\"No Fruit with id \"\
    \ + id + \" exists\");\n    }\n\n    @GetMapping(path = \"/color/{color}\", produces\
    \ = \"application/json\")\n    public List&lt;Fruit&gt; findByColor(@PathVariable(name\
    \ = \"color\") String color) {\n        return fruitRepository.findByColor(color);\n\
    \    }\n}\n</pre>\n\nNotice the use of familiar Spring annotations like `@GetMapping`\
    \ and `@PathVariable`. This exposes a set of RESTful APIs:\n\n* `GET /fruits`\
    \ - Retrieve all Fruits as a JSON array\n* `DELETE /fruits/{id}` - Delete by ID\n\
    * `POST /fruits/name/{name}/color/{color}` - create a new Fruit with a name and\
    \ color\n* `PUT /fruits/id/{id}/color/{color}` - Update a fruit with a new color\n\
    * `GET /fruits/color/{color}` - Retrieve all fruits of the specified color\n\n\
    # Test app\n\nWith this in place, we can now test our fruits access. The app is\
    \ still running, so simply click the following commands to do a few operations:\n\
    \nGet all fruits:\n\n`curl -s http://localhost:8080/fruits | jq`{{execute T2}}\n\
    \n> Note you may need to click the command again, if it didn't execute in the\
    \ new Terminal window.\n> **If you get a `parse error:`**, it is likely you missed\
    \ an earlier step, and the Quarkus live reload caught it. Click on the [app's\
    \ landing page](https://[[HOST_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com)\n\
    > to see details and clues about what may be wrong, and re-visit any prior steps\
    \ to re-add the missing code.\n\n> Note that we pass the output to the `jq` utility\
    \ which prints nicely-formatted JSON.\n\nYou should see:\n\n```json\n[\n  {\n\
    \    \"color\": \"red\",\n    \"id\": 1,\n    \"name\": \"cherry\"\n  },\n  {\n\
    \    \"color\": \"orange\",\n    \"id\": 2,\n    \"name\": \"orange\"\n  },\n\
    \  {\n    \"color\": \"yellow\",\n    \"id\": 3,\n    \"name\": \"banana\"\n \
    \ },\n  {\n    \"color\": \"green\",\n    \"id\": 4,\n    \"name\": \"avocado\"\
    \n  },\n  {\n    \"color\": \"red\",\n    \"id\": 5,\n    \"name\": \"strawberry\"\
    \n  }\n]\n```\n\nAdd a fruit:\n\n`curl -X POST -s http://localhost:8080/fruits/name/apple/color/red\
    \ | jq`{{execute T2}}\n\nGet all `red` fruits:\n\n`curl -s http://localhost:8080/fruits/color/red\
    \ | jq`{{execute T2}}\n\nNotice the presence of `apple` which we just added earlier.\n\
    \nChange the color of the `apple` to `green`:\n\n`curl -X PUT -s http://localhost:8080/fruits/id/6/color/green\
    \ | jq`{{execute T2}}\n\nAnd retrieve all green fruits:\n\n`curl -s curl -s http://localhost:8080/fruits/color/green\
    \ | jq`{{execute T2}}\n\nYou should see:\n\n```json\n[\n  {\n    \"color\": \"\
    green\",\n    \"id\": 4,\n    \"name\": \"avocado\"\n  },\n  {\n    \"color\"\
    : \"green\",\n    \"id\": 6,\n    \"name\": \"apple\"\n  }\n]\n```\n\nIndicating\
    \ that the color of our `apple` has changed to `green`.\n\n## Exercise Beans using\
    \ Spring DI Annotations\n\nAs a final test let's create another bean to use our\
    \ injected beans and configuration using Spring DI annotations.\n\nClick here\
    \ to create and open a new file for our taster controller for tasting Fruits:\
    \ `fruit-taster/src/main/java/org/acme/TasterController.java`{{open}}.\n\nClick\
    \ **Copy to Editor** to create the code for the controller:\n\n<pre class=\"file\"\
    \ data-filename=\"./fruit-taster/src/main/java/org/acme/TasterController.java\"\
    \ data-target=\"replace\">\npackage org.acme;\n\nimport java.util.ArrayList;\n\
    import java.util.List;\n\nimport org.springframework.web.bind.annotation.GetMapping;\n\
    import org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\
    \nimport org.springframework.web.bind.annotation.PathVariable;\n\n@RestController\n\
    @RequestMapping(\"/taster\")\npublic class TasterController {\n\n    private final\
    \ FruitRepository fruitRepository;\n\n    private final TasterBean tasterBean;\n\
    \n    public TasterController(FruitRepository fruitRepository, TasterBean tasterBean)\
    \ {\n        this.fruitRepository = fruitRepository;\n        this.tasterBean\
    \ = tasterBean;\n    }\n\n    @GetMapping(produces = \"application/json\")\n \
    \   public List&lt;TasteResult&gt; tasteAll() {\n        List&lt;TasteResult&gt;\
    \ result = new ArrayList<>();\n\n        fruitRepository.findAll().forEach(fruit\
    \ -> {\n            result.add(new TasteResult(fruit, tasterBean.taste(fruit.getName())));\n\
    \        });\n        return result;\n    }\n\n    @GetMapping(path = \"/{color}\"\
    , produces = \"application/json\")\n    public List&lt;TasteResult&gt; tasteByColor(@PathVariable(name\
    \ = \"color\") String color) {\n        List&lt;TasteResult&gt; result = new ArrayList<>();\n\
    \        fruitRepository.findByColor(color).forEach(fruit -> {\n            result.add(new\
    \ TasteResult(fruit, tasterBean.taste(fruit.getName())));\n        });\n     \
    \   return result;\n    }\n\n    public class TasteResult {\n        public Fruit\
    \ fruit;\n        public String result;\n\n        public TasteResult(Fruit fruit,\
    \ String result) {\n            this.fruit = fruit;\n            this.result =\
    \ result;\n        }\n\n    }\n}\n</pre>\n\nAgain, we're using Spring Rest annotations\
    \ like `@GetMapping` but we're also injecting our repository and taster bean in\
    \ the constructor. This controller exposes 2 RESTful APIs:\n\n* `GET /taster`\
    \ - taste all fruits and report result\n* `GET /taster/{color}` - Taste only fruits\
    \ of the specified color\n\nApp still running? Check. Let's test our new API:\n\
    \nTaste all the fruits:\n\n`curl -s http://localhost:8080/taster | jq`{{execute\
    \ T2}}\n\nYou should see:\n\n```json\n[\n  {\n    \"fruit\": {\n      \"color\"\
    : \"red\",\n      \"id\": 1,\n      \"name\": \"cherry\"\n    },\n    \"result\"\
    : \"CHERRY: TASTES GREAT !\"\n  },\n  {\n    \"fruit\": {\n      \"color\": \"\
    orange\",\n      \"id\": 2,\n      \"name\": \"orange\"\n    },\n    \"result\"\
    : \"ORANGE: TASTES GREAT !\"\n  },\n  {\n    \"fruit\": {\n      \"color\": \"\
    yellow\",\n      \"id\": 3,\n      \"name\": \"banana\"\n    },\n    \"result\"\
    : \"BANANA: TASTES GREAT !\"\n  },\n  {\n    \"fruit\": {\n      \"color\": \"\
    green\",\n      \"id\": 4,\n      \"name\": \"avocado\"\n    },\n    \"result\"\
    : \"AVOCADO: TASTES GREAT !\"\n  },\n  {\n    \"fruit\": {\n      \"color\": \"\
    red\",\n      \"id\": 5,\n      \"name\": \"strawberry\"\n    },\n    \"result\"\
    : \"STRAWBERRY: TASTES GREAT !\"\n  }\n]\n```\nTaste only the `green` fruits:\n\
    \n`curl -s http://localhost:8080/taster/green | jq`{{execute T2}}\n\n```\n[\n\
    \  {\n    \"fruit\": {\n      \"color\": \"green\",\n      \"id\": 4,\n      \"\
    name\": \"avocado\"\n    },\n    \"result\": \"AVOCADO: TASTES GREAT !\"\n  }\n\
    ]\n```\n\n## Add a suffix\n\nClick **Copy to Editor** to add a new suffix for\
    \ our taster:\n\n<pre class=\"file\" data-filename=\"./fruit-taster/src/main/resources/application.properties\"\
    \ data-target=\"append\">\ntaste.suffix = (if you like fruit!)\n</pre>\n\nAnd\
    \ taste yellow fruits:\n\n`curl -s http://localhost:8080/taster/yellow | jq`{{execute\
    \ T2}}\n\nYou should see:\n\n```json\n[\n  {\n    \"fruit\": {\n      \"color\"\
    : \"yellow\",\n      \"id\": 3,\n      \"name\": \"banana\"\n    },\n    \"result\"\
    : \"BANANA: TASTES GREAT (IF YOU LIKE FRUIT!)\"\n  }\n]\n```\n\nNotice the presence\
    \ of our new suffix! Quarkus apps make it super easy to code, test, and re-code\
    \ on the fly.\n\n## Cleanup\n\nWe're done coding, so let's stop the app. In the\
    \ first Terminal, press `CTRL-C` to stop the running Quarkus app (or click the\
    \ `clear`{{execute T1 interrupt}} command to do it for you).\n\n"
  difficulty: basic
  slug: 04-create-web
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 4
  type: challenge
- assignment: "## Build executable JAR\n\nQuarkus applications can be built as executable\
    \ JARs, or native binary images. Here we'll use an executable JAR to deploy our\
    \ app. Build the application:\n\n```\nmvn clean package -DskipTests\n```. It produces\
    \ 2 jar files:\n\n* `target/fruit-taster-1.0.0-SNAPSHOT.jar` - containing just\
    \ the classes and resources of the projects, it\u2019s the regular artifact produced\
    \ by the Maven build\n\n* `target/quarkus-app/quarkus-run.jar` - being an executable\
    \ jar. Be aware that it\u2019s not an \xFCber-jar as the dependencies are copied\
    \ into several subdirectories (and would need to be included in any layered container\
    \ image).\n\nSee the files with this command:\n\n```\nls -l target/*.jar target/quarkus-app/*.jar\n\
    ```\n\n> **NOTE**: Quarkus uses the _fast-jar_ packaging by default. The fast-jar\
    \ packaging format is introduced as an alternative to the default jar packaging\
    \ format. The main goal of this new format is to bring faster startup times.\n\
    \n## Run the executable JAR\n\nYou can run the packaged application by clicking:\n\
    \n```\njava -jar target/quarkus-app/quarkus-run.jar\n```\n\nMake sure the app\
    \ is still working as expected (we'll use `curl` this time to access it directly):\n\
    \n`curl -s http://localhost:8080/fruits | jq`{{execute T2}}\n\n## Cleanup\n\n\
    In the first Terminal, press `CTRL-C` to stop the running Quarkus native app (or\
    \ click the `clear`{{execute T1 interrupt}} command to do it for you).\n\n## Congratulations!\n\
    \nYou've now built a Java application as an executable JAR. Quarkus also supports\
    \ building to _native_ images providing even greater startup speed and memory\
    \ effeciency. Now let's give our app native powers by creating a Quarkus native\
    \ app.\n"
  difficulty: basic
  slug: 05-build-app
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 5
  type: challenge
- assignment: "Now that we have our app built, let's move it into containers and into\
    \ the cloud.\n\n## Install OpenShift extension\n\nQuarkus offers the ability to\
    \ automatically generate OpenShift resources based on sane default and user supplied\
    \ configuration. The OpenShift extension is actually a wrapper extension that\
    \ brings together the [kubernetes](https://quarkus.io/guides/deploying-to-kubernetes)\
    \ and [container-image-s2i](https://quarkus.io/guides/container-image#s2i) extensions\
    \ with defaults so that it\u2019s easier for the user to get started with Quarkus\
    \ on OpenShift.\n\nRun the following command to add it to our project:\n\n`mvn\
    \ quarkus:add-extension -Dextensions=\"openshift\"`{{execute T1}}\n\n## Login\
    \ to OpenShift\n\nWe'll deploy our app as the `developer` user. Run the following\
    \ command to login with the OpenShift CLI:\n\n`oc login -u developer -p developer`{{execute\
    \ T1}}\n\nYou should see\n\n```\nLogin successful.\n\nYou don't have any projects.\
    \ You can try to create a new project, by running\n\n    oc new-project <projectname>\n\
    ```\n\n## Create project\n\nFor this scenario, let's create a project that you\
    \ will use to house your applications. Click:\n\n`oc new-project quarkus-spring\
    \ --display-name=\"Sample Quarkus App using Spring APIs\"`{{execute T1}}\n\nBefore\
    \ we deploy the application we need to deploy the Postgres database.\n\n## Deploy\
    \ Postgres\n\nWhen running in production, we'll need a Postgres database on OpenShift.\
    \ Click the next command to deploy Postgres to your new project:\n\n`oc new-app\
    \ \\\n    -e POSTGRESQL_USER=sa \\\n    -e POSTGRESQL_PASSWORD=sa \\\n    -e POSTGRESQL_DATABASE=fruits\
    \ \\\n    -e POSTGRESQL_MAX_CONNECTIONS=200 \\\n    --name=postgres-database \\\
    \n    openshift/postgresql`{{execute T1}}`\n\n## Configure Quarkus\n\nSince we\
    \ are now deploying this to Openshift our database will no longer be on localhost.\
    \ And our production is running Postgres. How do we handle these multiple configurations?\
    \ Quarkus has a neat feature where we can create different profiles. So we will\
    \ use the %dev profile for our local environment.\n\nClick: `fruit-taster/src/main/resources/application.properties`{{open}}\
    \ to open this file. This file contains Quarkus configuration.\n\nClick **Copy\
    \ to Editor** to add the following values to the `application.properties` file:\n\
    \n<pre class=\"file\" data-filename=\"./fruit-taster/src/main/resources/application.properties\"\
    \ data-target=\"replace\">\n%dev.quarkus.datasource.db-kind=h2\n%dev.quarkus.datasource.jdbc.url=jdbc:h2:mem:rest-crud\n\
    %dev.quarkus.hibernate-orm.database.generation=drop-and-create\n%dev.quarkus.hibernate-orm.log.sql=true\n\
    \n# OpenShift Production Configuration\nquarkus.datasource.db-kind=postgresql\n\
    quarkus.datasource.jdbc.url=jdbc:postgresql://postgres-database:5432/fruits\n\
    quarkus.datasource.username=sa\nquarkus.datasource.password=sa\nquarkus.hibernate-orm.database.generation=drop-and-create\n\
    quarkus.hibernate-orm.sql-load-script = import.sql\n\ntaste.message = tastes great\n\
    taste.suffix = (if you like fruit!)\n</pre>\n\n## Deploy application to OpenShift\n\
    \nNow let's deploy the application itself. Run the following command which will\
    \ build and deploy the Quarkus app in Openshift:\n\n`mvn clean package \\\n-Dquarkus.kubernetes-client.trust-certs=true\
    \ \\\n-Dquarkus.container-image.build=true \\\n-Dquarkus.kubernetes.deploy=true\
    \ \\\n-Dquarkus.kubernetes.deployment-target=openshift \\\n-Dquarkus.openshift.route.expose=true\
    \ \\\n-DskipTests`{{execute T1}}`\n\nThe output should end with `BUILD SUCCESS`.\n\
    \nFor more details of the above options:\n\n* `quarkus.kubernetes-client.trust-certs=true`\
    \ - We are using self-signed certs in this simple example, so this simply says\
    \ to the extension to trust them.\n* `quarkus.container-image.build=true` - Instructs\
    \ the extension to build a container image\n* `quarkus.kubernetes.deploy=true`\
    \ - Instructs the extension to deploy to OpenShift after the container image is\
    \ built\n* `quarkus.kubernetes.deployment-target=openshift` - Instructs the extension\
    \ to generate and create the OpenShift resources (like `DeploymentConfig`s and\
    \ `Service`s) after building the container\n* `quarkus.openshift.route.expose=true`\
    \ - Instructs the extension to generate an OpenShift `Route` so we can access\
    \ our application from outside the OpenShift cluster\n\nFinally, make sure it's\
    \ actually done rolling out:\n\n`oc rollout status -w dc/fruit-taster`{{execute\
    \ T1}}\n\nWait (about 30 seconds) for that command to report `replication controller\
    \ \"fruit-taster-1\" successfully rolled out` before continuing.\n\n> If the `oc\
    \ rollout` command appears to not finish, just `CTRL-C` it and run it again.\n\
    \nAnd now we can access using `curl` once again:\n\n`curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster\
    \ | jq`{{execute T1}}\n\nYou should see the same fruits being tasted:\n\n```console\n\
    [\n  {\n    \"fruit\": {\n      \"color\": \"red\",\n      \"id\": 1,\n      \"\
    name\": \"cherry\"\n    },\n    \"result\": \"CHERRY: TASTES GREAT (IF YOU LIKE\
    \ FRUIT!)\"\n  },\n  ...\n```\n\n\nYou can also see the app deployed in the [OpenShift\
    \ Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus-spring)\n\
    \n\n## Scale the app\n\nWith that set, let's see how fast our app can scale up\
    \ to 10 instances:\n\n`oc scale --replicas=10 dc/fruit-taster`{{execute T1}}\n\
    \nBack in the [OpenShift Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus-spring)\
    \ you'll see the app scaling dynamically up to 10 pods:\n\n![Scaling](/openshift/assets/middleware/quarkus/scaling_spring.png)\n\
    \nWe now have 10 instances running providing better performance. Make sure it\
    \ still works:\n\n`curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster\
    \ | jq`{{execute T1}}\n\n**10 not enough? Try 50!** Click the command to scale\
    \ this app to 50 instances:\n\n`oc scale --replicas=50 dc/fruit-taster`{{execute\
    \ T1}}\n\n\nIt will take a bit longer to scale that much. In the meantime the\
    \ app continues to respond:\n\n`curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster\
    \ | jq`{{execute T1}}\n\nYou can watch the 50 pods spinning up:\n\n`oc get pods\
    \ -w -l app.kubernetes.io/name=fruit-taster`{{execute T1}}\n\nWatch as long as\
    \ you like, then `CTRL-C` the pod watcher.\n\nFinally, scale it back down:\n\n\
    `oc scale --replicas=1 dc/fruit-taster`{{execute T1}}\n\n# Open the solution in\
    \ an IDE in the Cloud!\nWant to continue exploring this solution on your own in\
    \ the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview)\
    \ IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox).\
    \ [Click here](https://workspaces.openshift.com) to login or to register if you\
    \ are a new user. This free service expires after 30 days, but you can always\
    \ enable a new free 30-day subscription.\n\nOnce logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/quarkus/spring/devfile.yaml)\
    \ to open the solution for this project in the cloud IDE. While loading, if it\
    \ asks you to update or install any plugins, you can say no.\n\n# Fork the source\
    \ code to your own GitHub!\nWant to experiment more with the solution code you\
    \ just worked with? If so, you can fork the repository containing the solution\
    \ to your own GitHub repository by clicking on the following command to execute\
    \ it:\n\n`/root/projects/forkrepo.sh`{{execute T1}}\n- Make sure to follow the\
    \ prompts. An error saying `Failed opening a web browser at https://github.com/login/device\
    \ exit status 127` is expected.\n- [Click here](https://github.com/login/device)\
    \ to open a new browser tab to GitHub and paste in the code you were presented\
    \ with and you copied.\n- Once done with the GitHub authorization in the browser,\
    \ close the browser tab and return to the console and press `Enter` to complete\
    \ the authentication process.\n- If asked to clone the fork, press `n` and then\
    \ `Enter`.\n- If asked to confirm logout, press `y` and the `Enter`.\n\n   > **NOTE:**\
    \ This process uses the [GitHub CLI](https://cli.github.com) to authenticate with\
    \ GitHub. The learn.openshift.com site is not requesting nor will have access\
    \ to your GitHub credentials.\n\nAfter completing these steps the `rhoar-getting-started`\
    \ repo will be forked in your own GitHub account. On the `solution` branch in\
    \ the repo, the `spring` project inside the `quarkus` folder contains the completed\
    \ solution for this scenario.\n\n## Congratulations!\n\nThis step covered the\
    \ deployment of a Quarkus application on OpenShift using Spring compatibility\
    \ APIs. To try out the native features, try the Getting Started tutorial. There\
    \ is much more, and the integration with these environments has been tailored\
    \ to make Quarkus applications execution very smooth."
  difficulty: basic
  slug: 06-deploy-and-test
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Step 6
  type: challenge
description: 'This exercise demonstrates how Spring and Spring Boot developers can
  use well-known Spring annotations for Spring Data, Web, and Dependency Injection
  when building Quarkus applications. Spring developers can quickly become productive
  with Quarkus using existing knowledge and familiarity of these APIs.


  You''ll build a relatively simple application that uses Spring Data to integrate
  (via JPA) with an underlying database, inject beans using Spring DI and expose them
  as RESTful endpoints via Spring Rest.


  ### Other possibilities


  Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!'
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: openshift
private: true
published: false
skipping_enabled: false
slug: spring
tags:
- openshift
title: Quarkus for Spring Boot Developers
type: track
