slug: developing-with-quarkus-panache
id: epiodrxuvz7f
type: track
title: Effective Data with Hibernate and Panache
description: |-
  In this scenario, you will get an introduction to **Panache**, one of the many features of [Quarkus](https://quarkus.io).

  ## What is Panache?

  Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but many simple and common mappings can also be complex. Hibernate ORM with **Panache** focuses on making your entities trivial and fun to write and use with Quarkus.

  With Panache, we took an opinionated approach to make hibernate as easy as possible. Hibernate ORM with Panache offers the following:

  * By extending `PanacheEntity` in your entities, you will get an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheEntityBase` instead and handle the ID yourself.

  * By using Use public fields, there is no need for functionless getters and setters (those that simply get or set the field). You simply refer to fields like `Person.name` without the need to write a `Person.getName()` implementation. Panache will auto-generate any getters and setters you do not write, or you can develop your own getters/setters that do more than get/set, which will be called when the field is accessed directly.

  * The `PanacheEntity` superclass comes with lots of super useful static methods and you can add your own in your derived entity class, and much like traditional object-oriented programming it's natural and recommended to place custom queries as close to the entity as possible, ideally within the entity definition itself. Users can just start using your entity `Person` by typing `Person`, and getting completion for all the operations in a single place.

  * You don't need to write parts of the query that you don’t need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` or even better `Person.find("name", "stef")`.

  That’s all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.

  ### Other possibilities

  Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- doh@redhat.com
private: false
published: true
challenges:
- slug: 01-define-entity
  id: xtogugtshdy5
  type: challenge
  title: Define Entity
  notes:
  - type: text
    contents: |-
      In this scenario, you will get an introduction to **Panache**, one of the many features of [Quarkus](https://quarkus.io).

      ## What is Panache?

      Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but many simple and common mappings can also be complex. Hibernate ORM with **Panache** focuses on making your entities trivial and fun to write and use with Quarkus.

      With Panache, we took an opinionated approach to make hibernate as easy as possible. Hibernate ORM with Panache offers the following:

      * By extending `PanacheEntity` in your entities, you will get an ID field that is auto-generated. If you require a custom ID strategy, you can extend `PanacheEntityBase` instead and handle the ID yourself.

      * By using Use public fields, there is no need for functionless getters and setters (those that simply get or set the field). You simply refer to fields like `Person.name` without the need to write a `Person.getName()` implementation. Panache will auto-generate any getters and setters you do not write, or you can develop your own getters/setters that do more than get/set, which will be called when the field is accessed directly.

      * The `PanacheEntity` superclass comes with lots of super useful static methods and you can add your own in your derived entity class, and much like traditional object-oriented programming it's natural and recommended to place custom queries as close to the entity as possible, ideally within the entity definition itself. Users can just start using your entity `Person` by typing `Person`, and getting completion for all the operations in a single place.

      * You don't need to write parts of the query that you don’t need: write `Person.find("order by name")` or `Person.find("name = ?1 and status = ?2", "stef", Status.Alive)` or even better `Person.find("name", "stef")`.

      That’s all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.

      ### Other possibilities

      Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!
  assignment: |+
    In this step, you will start with a simple RESTful application generated from the Quarkus tooling, and then define a new entity to work on, which will be persisted in a typical database through JDBC.

    # Inspect Java runtime

    An appropriate Java runtime has been installed for you. Ensure you can use it by running this command in Terminal 1:

    > If the command fails, wait a few moments and try again (it is installed in a background process and make take a few moments depending on system load).

    ```
    $JAVA_HOME/bin/java --version
    ```

    The command should report the version in use, for example (the versions and dates may be slightly different than the below example):

    ```console
    openjdk 11 2018-09-25
    OpenJDK Runtime Environment 18.9 (build 11+28)
    OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)
    ```

    ## Import the code

    Let's refresh the code we'll be using. Run the following command to clone the sample project:

    ```
    cd /root/projects && rm -rf rhoar-getting-started && git clone https://github.com/openshift-katacoda/rhoar-getting-started
    ```

    # Inspect project

    Make sure you're in the right project directory by runing:

    ```
    cd /root/projects/rhoar-getting-started/quarkus/panache
    ```

    Initially, the project is almost empty and doesn't do anything. Start by reviewing the content by switching to the *Visual Editor* Tab.

    As you can see, there are some files that we have prepared for you in the project. Under `src/main/resources/META-INF/resources` we have for example prepared an html file for you, and some skeletal model files and utilities. This matches what you might get when generating sample projects [using the Quarkus Project Generator](https://code.quarkus.io).

    We need to add a few extensions to the app for Panache and Postgres. We'll use the Quarkus Maven Plugin.

    Run this command to add the Hibernate ORM with Panache and PostgreSQL JDBC extensions:

    ```
    mvn quarkus:add-extension -Dextensions="hibernate-orm-panache, jdbc-postgresql"
    ```

    You should see:

    ```console
    [SUCCESS] ✅ Extension io.quarkus:quarkus-hibernate-orm-panache has been installed
    [SUCCESS] ✅ Extension io.quarkus:quarkus-jdbc-postgresql has been installed
    ```

    Done!

    > There are [many more extensions](https://quarkus.io/extensions/) for Quarkus for popular frameworks like [Eclipse Vert.x](https://vertx.io), [Apache Camel](http://camel.apache.org/), [Infinispan](http://infinispan.org/), Spring DI compatibility (e.g. `@Autowired`), and more.

    For more detail on basic Quarkus usage, check out the [Getting Started](https://learn.openshift.com/middleware/courses/middleware-quarkus/getting-started) scenario. We'll assume you've worked through that and understand the basics of a Quarkus app.

    # Define the entity

    This app will be a database of people, each of which have a name, birthdate, and eye color. We'll need an entity, from the **Visual Editor** tabs.

    Open this file `src/main/java/org/acme/person/model/Person.java` and replace withe the following entity definition:

    ```java
    package org.acme.person.model;

    import java.time.LocalDate;
    import java.util.List;
    import java.util.stream.Collectors;

    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.EnumType;
    import javax.persistence.Enumerated;

    import io.quarkus.hibernate.orm.panache.PanacheEntity;

    @Entity
    public class Person extends PanacheEntity {
        // the person's name
        public String name;

        // the person's birthdate
        public LocalDate birth;

        // the person's eye color
        @Enumerated(EnumType.STRING)
        @Column(length = 8)
        public EyeColor eyes;

        // TODO: Add more queries
    }
    ```

    Click on the `Disk` icon to save the files or press `CTRL-S`:

    ![Visual Editor](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/save-person-file.png)

    > You'll see a `// TODO` line - **do not delete it!** We will use this later on.

    As you can see we've defined the three fields `name`, `birth`, and `eyes`. We're using the Java Persistence API's `@Enumerated` field type for our eye color.

    We'll also need the definition of eye colors, so let's create an `enum`. Create a new `src/main/java/org/acme/person/model/EyeColor.java` files:

    ![File](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/create-file-eye.png)

    Open the `EyeColor.java` file then add the following enum definition:

    ```java
    package org.acme.person.model;

    public enum EyeColor {
        BLUE, GREEN, HAZEL, BROWN
    }
    ```

    Save the file.

    # Define the RESTful endpoint

    Next, we'll create a `PersonResource` class which we will use for our RESTful endpoint. From the **Visual Editor** Tab, create a new file in this path : `src/main/java/org/acme/person/PersonResource.java` and add its code:



    open the `PersonResource.java` file then add this code:

    ```java
    package org.acme.person;

    import java.time.LocalDate;
    import java.util.List;
    import java.util.stream.Collectors;

    import javax.enterprise.event.Observes;
    import javax.transaction.Transactional;
    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.PathParam;
    import javax.ws.rs.Produces;
    import javax.ws.rs.QueryParam;
    import javax.ws.rs.core.MediaType;

    import org.acme.person.model.DataTable;
    import org.acme.person.model.EyeColor;
    import org.acme.person.model.Person;

    import io.smallrye.common.annotation.Blocking;
    import io.quarkus.panache.common.Parameters;
    import io.quarkus.runtime.StartupEvent;
    import io.quarkus.hibernate.orm.panache.PanacheQuery;

    @Path("/person")
    @Blocking
    public class PersonResource {

        @GET
        @Produces(MediaType.APPLICATION_JSON)
        public List<Person> getAll() {
            return Person.listAll();
        }

        // TODO: add basic queries

        // TODO: add datatable query

        // TODO: Add lifecycle hook

    }
    ```

    Save the file.

    > You'll see a lot of `// TODO` lines - **do not delete them!** We will use these later on.

    As you can see we've implemented our first Panache-based query, the `getAll` method, which will return our list of people as a JSON object when we access the `GET /person` endpoint. This is defined using standard JAX-RS `@Path` and `@GET` and `@Produces` annotations.

    # Add sample data

    Let's add some sample data to the database so we can test things out. From the **Visual Editor** Tab, open this file : `src/main/resources/import.sql` and add some SQL statements to run on startup:

    ```text
    INSERT INTO person(id, name, birth, eyes) VALUES (nextval('hibernate_sequence'), 'Farid Ulyanov', to_date('1974-08-15', 'YYYY-MM-dd'), 'BLUE');
    INSERT INTO person(id, name, birth, eyes) VALUES (nextval('hibernate_sequence'), 'Salvador L. Witcher', to_date('1984-05-24', 'YYYY-MM-dd'), 'BROWN');
    INSERT INTO person(id, name, birth, eyes) VALUES (nextval('hibernate_sequence'), 'Huynh Kim Hue', to_date('1999-04-25', 'YYYY-MM-dd'), 'HAZEL');
    ```

    These statements will add some fake people to our database. Save the file.

  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
- slug: 02-remote-dev
  id: mjqxevryv5x0
  type: challenge
  title: Setup Remove Development
  assignment: |+
    # Remote Live Coding

    What if you want to expand the inner loop development cycle to a remote container environment such as Kubernetes or OpenShift? You can configure your application in remote development mode to make changes to your local files immediately visible in your remote container environment. This allows you to develop in the same environment you will actually run your app in, and with access to the same services.

    We'll deploy our base application to OpenShift and connect it to your local environment. The end result will be a fully functional app, already running on the target platform (OpenShift).

    ## Open the OpenShift Web Console

    OpenShift ships with a web-based console that will allow users to
    perform various tasks via a browser.

    Access the OpenShift Web Console to also login from the Web UI:

    ```
    oc get routes console -n openshift-console -o jsonpath='{"https://"}{.spec.host}{"\n"}'
    ```

    Copy the URL from the output of the above command and open it in your browser.

    We'll deploy our app as the `developer` user. Use the following credentials:

    * Username:
    ```
    developer
    ```

    * Password:
    ```
    developer
    ```


    ![Web Console Login](https://katacoda.com/openshift/assets/middleware/quarkus/login.png)

    Run **Skip Tour** to skip the new user introduction.

    There's nothing there now ("No workloads found"), but that's about to change.

    ## Login to OpenShift

    In order to login, we will use the **oc** command and then specify the server that we
    want to authenticate to:

    ```
    oc login -u developer -p developer
    ```

    This will automatically log you in as the user `developer` whose password is `developer`.

    > If the above `oc login` command doesn't seem to do anything, you may have forgotten to stop the application from the previous
    step. Run in the first terminal and press CTRL-C to stop the application and try to `oc login` again!

    ## Access OpenShift Project

    For this scenario, let's create a project that you will use to house your applications. Run:

    ```
    oc new-project quarkus --display-name="Sample Quarkus Datatable App"
    ```



    ## Deploy Postgres

    Our app will need a Postgres database. Run the next command to quickly deploy a Postgres instance to your new project:

    ```
    oc new-app \
        -e POSTGRESQL_USER=sa \
        -e POSTGRESQL_PASSWORD=sa \
        -e POSTGRESQL_DATABASE=person \
        --name=postgres-database \
        -l app.openshift.io/runtime=postgresql \
        openshift/postgresql
    ```

    You'll see the Postgres pod spinning up in the Web Console.

    ![Postgres pod](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/people-postgres-new.png)

    ## Add Quarkus OpenShift extension

    Quarkus offers the ability to automatically generate OpenShift resources based on sane defaults and user supplied configuration. The OpenShift extension is actually a wrapper extension that brings together the [kubernetes](https://quarkus.io/guides/deploying-to-kubernetes) and [container-image-s2i](https://quarkus.io/guides/container-image#s2i) extensions with defaults so that it’s easier for the user to get started with Quarkus on OpenShift.

    Run the following command to add it to our project:

    ```
    cd /root/projects/rhoar-getting-started/quarkus/panache && \
      mvn quarkus:add-extension -Dextensions="openshift"
    ```

    You will see:

    ```console
    [SUCCESS] ✅ Extension io.quarkus:quarkus-openshift has been installed
    ```

    ## Configure Quarkus for remote live coding

    From the **Visual Editor** Tab, open this file : `src/main/resources/application.properties`. This file contains Quarkus configuration.

    Add the following values to the `application.properties` file:

    ```text
    # Remote Live Coding setup
    quarkus.package.type=mutable-jar
    quarkus.live-reload.password=changeit

    # OpenShift Production Configuration
    quarkus.datasource.db-kind=postgresql
    quarkus.datasource.jdbc.url=jdbc:postgresql://postgres-database:5432/person
    quarkus.datasource.username=sa
    quarkus.datasource.password=sa
    quarkus.hibernate-orm.database.generation=drop-and-create
    quarkus.hibernate-orm.sql-load-script = import.sql
    ```

    Save the file.

    The `quarkus.package.type=mutable-jar` instructs Quarkus to package the app as a _mutable_ app. Mutable applications also include the deployment time parts of Quarkus (need for dev mode), so they take up a bit more disk space. If run normally they start just as fast and use the same memory as an immutable application, however they can also be started in dev mode.

    We also configure Quarkus to use the Postgres database, using `postgres-database` as the hostname (which is resolved by OpenShift to the running Postgres database host).

    > **NOTE:** that you can change the remote live-reload password to whatever you want. It is used to secure communication between the remote side and the local side.

    ## Deploy application to OpenShift

    Run the following command which will build and deploy the Quarkus app in Openshift. There's a number of arguments (which could optionally be put in `application.properties`) that are explained below.

    ```
    mvn clean package -DskipTests \
    -Dquarkus.kubernetes.deploy=true \
    -Dquarkus.container-image.build=true \
    -Dquarkus.kubernetes-client.trust-certs=true \
    -Dquarkus.kubernetes.deployment-target=openshift \
    -Dquarkus.openshift.route.expose=true \
    -Dquarkus.openshift.annotations.\"app.openshift.io/connects-to\"=postgres-database \
    -Dquarkus.openshift.env.vars.quarkus-launch-devmode=true
    ```

    The output should end with `BUILD SUCCESS`.

    For more details of the above options:

    * `quarkus.kubernetes.deploy=true` - Instructs the extension to deploy to OpenShift after the container image is built
    * `quarkus.container-image.build=true` - Instructs the extension to build a container image
    * `quarkus.kubernetes-client.trust-certs=true` - We are using self-signed certs in this simple example, so this simply says to the extension to trust them.
    * `quarkus.kubernetes.deployment-target=openshift` - Instructs the extension to generate and create the OpenShift resources (like `DeploymentConfig`s and `Service`s) after building the container
    * `quarkus.openshift.route.expose=true` - Instructs the extension to generate an OpenShift `Route` so we can access it from our browser.
    * `quarkus.kubernetes.annotations."app.openshift.io/connects-to"=postgres-database` - Adds a visual connector to show the DB connection in the web console topology view.
    * `quarkus.openshift.env.vars.quarkus-launch-devmode=true` - Sets an environment variable in the container to tell Quarkus to launch in dev mode (not production mode which is the default when deploying to Kubernetes or OpenShift)

    Finally, make sure it's actually done rolling out:

    ```
    oc rollout status -w dc/people
    ```

    Wait (about 30 seconds) for that command to report `replication controller "people-1" successfully rolled out` before continuing.

    > If the `oc rollout` command appears to not finish, just `CTRL-C` it and run it again.

    You can see it on the OpenShift Web Console.

    ![Quarkus pod](https://katacoda.com/openshift/assets/middleware/quarkus/people-quarkus.png)

    Do a quick test to ensure the remote app is running by using `curl` to retrieve the list of sample people:

    To get the URL from command line, from *Terminal 1* run this command to get the app's Route:

    ```
    oc get route people -n quarkus -o jsonpath='{"http://"}{.spec.host}'
    ```

    Copy the URL from the output of the above command and open it in your browser.

    ```
    export APP_URL=`oc get route people -n quarkus -o jsonpath='{"http://"}{.spec.host}'`
    curl -s $APP_URL/person | jq
    ```

    > You may need to run this again if the initial run opens a Terminal but doesn't run the command for you.

    You should see:

    ```json
    [
      {
        "id": 1,
        "birth": "1974-08-15",
        "eyes": "BLUE",
        "name": "Farid Ulyanov"
      },
      {
        "id": 2,
        "birth": "1984-05-24",
        "eyes": "BROWN",
        "name": "Salvador L. Witcher"
      },
      {
        "id": 3,
        "birth": "1999-04-25",
        "eyes": "HAZEL",
        "name": "Huỳnh Kim Huê"
      }
    ]
    ```

    The app is now running on OpenShift. In the next step we will connect to it via Quarkus' Remote Development feature so that the running app is updated as we make changes.

    # Save Environment variable

    We'll refer to this URL often, so run this command to save it in an environment variable called `APP_URL` (and put it in the Bash shell startup in case we open new terminals later):

    ```bash
    echo "export APP_URL=${APP_URL}" >> /root/.bashrc
    ```

    # Congratulations!

    You've seen how to build a basic app and add a simple query using Panache, and setup a remote connection to live code your application as it runs in the target environment.

    In the next step we'll add some more Panache queries and compare and contrast vs. ordinary Hibernate/JQL queries.

  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
- slug: 03-add-query-endpoints
  id: nehh6n9bynzo
  type: challenge
  title: Add Queries
  assignment: |
    In the previous step you created a basic RESTful Java application with Quarkus and a single Panache-based query. In this step we'll add a few more queries to demonstrate the ease of Panache queries vs. ordinary Hibernate/JQL queries.

    # Remote Dev Connection

    Now we are ready to run our in dev mode and connect it to the remote application. Run here to run in Terminal 1:

    ```
    mvn quarkus:remote-dev -Dquarkus.live-reload.url=$APP_URL -f /root/projects/rhoar-getting-started/quarkus/panache
    ```

    You should see a bunch of log output including:

    ```console
    INFO  [io.qua.ver.htt.dep.dev.HttpRemoteDevClient] (Remote dev client thread) Connected to remote server
    ```

    Your locally running Quarkus app is now connected to the remote side running on OpenShift, and changes you make here will be immediately reflected live in the remote application. Cool!

    You will leave this connection up and running and live code using it in the next step.

    ## Add Queries

    Let’s modify the application and add some queries. Much like traditional object-oriented programming, Panache and Quarkus recommend you place your custom entity queries as close to the entity definition as possible, in this case in the entity definition itself.

    From the **Visual Editor** Tab, open the `Person` entity from this path: `src/main/java/org/acme/person/model/Person.java`.

    Add the following two new queries after `// TODO: Add more queries` comment:

    ```java
    public static List<Person> findByColor(EyeColor color) {
        return list("eyes", color);
    }

    public static List<Person> getBeforeYear(int year) {
        return Person.<Person>streamAll()
        .filter(p -> p.birth.getYear() <= year)
        .collect(Collectors.toList());
    }
    ```

    Save the file.

    These two queries will find a list of people in our database based on eye color, or birth year. Note the `getBeforeYear` is implemented using the Java Streams API.

    > All list methods in Panache-based entities (those that extend from `PanacheEntity`) have equivalent stream versions. So `list` has a `stream` variant, `listAll`-->`streamAll` and so on.

    With our custom entity queries implemented in our `Person` entity class, let's add RESTful endpoints to `PersonResource` to access them.

    Open the `src/main/java/org/acme/person/PersonResource.java` resource class once again to inject the new endpoints which will access our new queries after `// TODO: add basic queries` comment:

    ```java
        @GET
        @Path("/eyes/{color}")
        @Produces(MediaType.APPLICATION_JSON)
        public List<Person> findByColor(@PathParam(value = "color") EyeColor color) {
            return Person.findByColor(color);
        }

        @GET
        @Path("/birth/before/{year}")
        @Produces(MediaType.APPLICATION_JSON)
        public List<Person> getBeforeYear(@PathParam(value = "year") int year) {
            return Person.getBeforeYear(year);
        }
    ```

    Save the file.

    ## Inspect the results

    When you make these changes, Quarkus will notice all of these changes and live reload them across the remote connection.

    Check that it works as expected by testing the new endpoints. Let's find all the people with `BLUE` eyes. Execute in Terminal 2:

    ```
    curl -s $APP_URL/person/eyes/BLUE | jq
    ```

    > This will open a new Terminal to execute the command. If the command fails to run just run the above command again!

    You should only see **one** person with BLUE eyes:

    ```console
    [
      {
        "id": 1,
        "birth": "1974-08-15",
        "eyes": "BLUE",
        "name": "Farid Ulyanov"
      }
    ]
    ```
    This also confirms that our remote live coding is working as expected.

    Next, let's find people born in 1990 or earlier:

    ```
    curl -s $APP_URL/person/birth/before/1990 | jq
    ```

    You should see **two** people born in 1990 or earlier:

    ```console
    [
      {
        "id": 1,
        "birth": "1974-08-15",
        "eyes": "BLUE",
        "name": "Farid Ulyanov"
      },
      {
        "id": 2,
        "birth": "1984-05-24",
        "eyes": "BROWN",
        "name": "Salvador L. Witcher"
      }
    ]
    ```

    ## Congratulations!

    The `Person` entity's superclass comes with lots of super useful static methods and you can add your own in your entity class. Users can just start using your entity `Person` by typing `Person`, and getting completion for all the operations in a single place.

    In the next step we'll show you how Panache can help to adapt entities to high performance frontends, even in the face of millions of records. On to the next scenario!

    Make sure to stop the Quarkus Dev mode via pressing `CTRL-C` in Terminal 1.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Terminal 2
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
- slug: 04-add-paging-filtering
  id: xasxnvxdymkl
  type: challenge
  title: Add Paging/Filtering
  assignment: |
    In the previous step you added a few more custom queries to your entity and the associated RESTful endpoints. In this step we'll build a slightly more complex query including filtering, searching and paging capabilities.

    # Showing data in tables

    Earlier we used `curl` to access our data, which is very useful for testing, but for real applications you will usually surface the data in other ways, like on web pages using tables, with options for searching, sorting, filtering, paging, etc. Quarkus and Panache make this easy to adapt your application for any display library or framework.

    Let's use a popular jQuery-based plugin called [DataTables](https://www.datatables.net/). It features a *server-side* processing mode where it depends on the server (in this case our Quarkus app) to do searching, filtering, sorting, and paging. This is useful for very large datasets, on the order of hundreds of thousands of records or more. Transmitting the entire data set to the client browser is ineffecient at best, and will crash browsers, increase networking usage, and frustrate users at worst. So let's just return the exact data needed to be shown.

    # Add new endpoint

    [DataTables documentation](https://www.datatables.net/manual/server-side) shows that its frontend will call an endpoint on the backend to retrieve some amount of data. It will pass several query parameters to tell the server what to sort, filter, search, and which data to return based on the page size and current page the user is viewing. For this example, we'll only support a subset:

    * `start` - The index of the first element needed
    * `length` - Total number records to return (or less, if there are less records that meet criteria)
    * `search[value]` - The value of the search box
    * `draw` - DataTables does asnychronous processing, so this value is sent with each request, expecting it to be returned as-is, so DataTables can piece things back together on the frontend if a user runs things quickly.

    From the **Visual Editor** Tab, open the file in this path: `src/main/java/org/acme/person/PersonResource.java`.

    Add this snippet after `// TODO: add datatable query` comment:

    ```java
        @GET
        @Path("/datatable")
        @Produces(MediaType.APPLICATION_JSON)
        public DataTable datatable(
          @QueryParam(value = "draw") int draw,
          @QueryParam(value = "start") int start,
          @QueryParam(value = "length") int length,
          @QueryParam(value = "search[value]") String searchVal

          ) {
            // TODO: Begin result

            // TODO: Filter based on search

            // TODO: Page and return

        }
    ```

    Save the file.

    Here we are using JAX-RS `@QueryParam` values to specify the incoming parameters and be able to use them when the frontend calls the `GET /person/datatable` endpoint.

    We'll fill in the `TODO`s to build this method.

    DataTables requires a specific JSON payload to be returned from this, and we've pre-created a POJO `DataTable` class representing this structure in `src/main/java/org/acme/person/model/DataTable.java`. This simple structure includes these fields:

    * `draw` - The async processing record id
    * `recordsTotal` - Total records in database
    * `recordsFiltered` - Total records that match filtering criteria
    * `data` - The actual array of records
    * `error` - Error string, if any

    So, in our `PersonResource` endpoint, we'll start with an empty `result` object using the pre-created `DataTable` model.

    Add this code in the same file after the `// TODO: Begin result` comment:

    ```java
          DataTable result = new DataTable();
            result.setDraw(draw);
    ```

    Next, if the request includes a search parameter, let's take care of that by including a search query, otherwise just collect all records:

    Add this code in the same file after the `//TODO: Filter based on search` comment:

    ```java
          PanacheQuery<Person> filteredPeople;

          if (searchVal != null && !searchVal.isEmpty()) {
              filteredPeople = Person.<Person>find("name like :search",
                Parameters.with("search", "%" + searchVal + "%"));
          } else {
              filteredPeople = Person.findAll();
          }
    ```

    And finally, we use the built-in Panache `page` operator to seek to the correct page of records and stream the number of entries desired, set the values into the `result` and return it:

    Add this code in the same file after the `//TODO: Page and return` comment:

    ```java
            int page_number = start / length;
            filteredPeople.page(page_number, length);

            result.setRecordsFiltered(filteredPeople.count());
            result.setData(filteredPeople.list());
            result.setRecordsTotal(Person.count());

            return result;
    ```

    Save the file.

    Reconnect to the remote Quarkus app on OpenShift using the following command in Terminal 1:

    ```bash
    mvn quarkus:remote-dev -Dquarkus.live-reload.url=$APP_URL -f /root/projects/rhoar-getting-started/quarkus/panache
    ```

    Let's test out our new endpoint using `curl` to search for names with `yan` in their name in Terminal 2:

    ```
    curl -s "$APP_URL/person/datatable?draw=1&start=0&length=10&search\[value\]=yan" | jq
    ```

    This should return a single entity (since in our 3-person sample data, only one has `yan` in their name), embedded in the return object that DataTable is expecting (with the `draw`, `recordsFiltered`, `recordsTotal` etc):

    ```json
    {
      "data": [
        {
          "id": 1,
          "birth": "1974-08-15",
          "eyes": "BLUE",
          "name": "Farid Ulyanov"
        }
      ],
      "draw": 1,
      "recordsFiltered": 1,
      "recordsTotal": 3
    }
    ```

    # Congratulations

    You have successfully written an endpoint that can be used with 3rd-party frontend plugins like DataTable. In the next step we'll create a lot more data and deploy to OpenShift.

    Make sure to stop the Quarkus Dev mode via pressing `CTRL-C` in Terminal 1.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Terminal 2
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
- slug: 05-add-lifecycle-task
  id: cg5cuj6vclb5
  type: challenge
  title: Add Startup Task
  assignment: |
    In the previous step you built a slightly more complex query including filtering, searching and paging capabilities.  In this step we'll add a Quarkus Lifecycle Hook to pre-populate the database with 10k records.

    # Adding Lifecycle hook

    You often need to execute custom actions when the application starts and clean up everything when the application stops. In this case we'll add an action that will pre-generate a lot of fake data.

    Managed beans (like our `PersonResource`) can listen for lifecycle events by using the `@Observes` annotation on method signatures, which will be called when the associated event occurs.

    From the **Visual Editor** Tab, open the file in this path: `src/main/java/org/acme/person/PersonResource.java` once again to inject the lifecycle listener:

    Add this code in the same file after the `TODO: Page and return` comment: `//TODO: Add lifecycle hook`:

    ```java
        @Transactional
        void onStart(@Observes StartupEvent ev) {
            for (int i = 0; i < 10000; i++) {
                String name = CuteNameGenerator.generate();
                LocalDate birth = LocalDate.now().plusWeeks(Math.round(Math.floor(Math.random() * 20 * 52 * -1)));
                EyeColor color = EyeColor.values()[(int)(Math.floor(Math.random() * EyeColor.values().length))];
                Person p = new Person();
                p.birth = birth;
                p.eyes = color;
                p.name = name;
                Person.persist(p);
            }
        }
    ```

    Save the file.

    This code will insert 10,000 fake people with random birthdates, eye colors, and names at startup.

    Although this is listening for `StartupEvent`, and our application has already started, in `quarkus:dev` mode Quarkus will still fire this event once. S

    Let's test it out and see if it picks up our new data.

    Reconnect to the remote Quarkus app on OpenShift using the following command in Terminal 1:

    ```bash
    mvn quarkus:remote-dev -Dquarkus.live-reload.url=$APP_URL -f /root/projects/rhoar-getting-started/quarkus/panache
    ```

    We'll search for a single letter `F` and limit the results to `2` in Terminal 2:

    > Note that adding 10k entries will make startup time artificially high, around 5-10 seconds.

    ```
    curl -s "$APP_URL/person/datatable?draw=1&start=0&length=2&search\[value\]=F" | jq
    ```

    You should get up to 2 records returned, but the total number available should show many more indicating our search found many more, and the total number of records should now be `10003` (the 10k we added plus the 3 original values):

    ```json
    {
      "data": [
        {
          "id": 1,
          "birth": "1974-08-15",
          "eyes": "BLUE",
          "name": "Farid Ulyanov"
        },
        {
          "id": 10,
          "birth": "2001-11-26",
          "eyes": "GREEN",
          "name": "Phantom Finger"
        }
      ],
      "draw": 1,
      "recordsFiltered": 1316,
      "recordsTotal": 10003
    }
    ```

    Note the values for `recordsFiltered` (the number of records with the letter `F` in the name), and `recordsTotal`. The value you see for `recordsFiltered` may be different than the above value, since the number of records with an `F` in the name may vary since the data is random.

    # Congratulations

    You have successfully written a lifecycle hook to listen for `StartupEvent`. Anytime the application is started it will fire this method. You can also use `@Observes ShutdownEvent` to do cleanup when the application is gracefully stopped.

    In the next step we'll exercise the DataTables GUI, backed by our remotely developed, high performance Quarkus app!

    Make sure to stop the Quarkus Dev mode via pressing `CTRL-C` in Terminal 1.
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Terminal 2
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
- slug: 06-exercise-table
  id: brgo3c9xkxaz
  type: challenge
  title: Exercise Table
  assignment: |
    Now that we have our app running on OpenShift, let's see what we can do.

    Access the OpenShift Web Console, and go to the `quarkus` project. Click on `Open URL` in Topology view:

    ![Web Console Overview](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/quarkus/panache-reactive-datatable-topology.png)

    It should look like:

    ![Web Console Overview](https://katacoda.com/openshift/assets/middleware/quarkus/panache-datatable.png)

    Notice the total number of records reported at the bottom. Type in a single letter, e.g. `F` in the search box and see how responsive the app is. Type additional letters to narrow the search. Rather than having all 10k records loaded in the browser, DataTable makes a call back to our `/person/datatable` REST endpoint to fetch only those records that should be shown, based on page size, current page you're looking at, and any search filters. With a page size of `10` each REST call will only return up to 10 records, no matter how many there are in the database.

    Skip around a few pages, try some different searches, and notice that the data is only loaded when needed. The overall performance is very good even for low-bandwidth connections or huge data sets.

    # Open the solution in an IDE in the Cloud!
    Want to continue exploring this solution on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview) IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox). [Run here](https://workspaces.openshift.com) to login or to register if you are a new user. This free service expires after 30 days, but you can always enable a new free 30-day subscription.

    Once logged in, [run here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/quarkus/panache/devfile.yaml) to open the solution for this project in the cloud IDE. While loading, if it asks you to update or install any plugins, you can say no.

    ## Congratulations

    In this scenario you got a glimpse of the power of Quarkus apps when dealing with large amounts of data.

    You also got to experience Quarkus Remote Development, where local changes are immediately reflected in remote applications. You deployed the app to OpenShift and live-coded changes on the fly.

    There is much more to Quarkus than this, so keep on exploring additional scenarios to learn more, and be sure to visit [quarkus.io](https://quarkus.io) to learn even more about the architecture and capabilities of this exciting new framework for Java developers.

    # Extra Credit

    There are [many other features of DataTables](https://datatables.net/manual/server-side) that could be supported on the server side with Quarkus and Panache. For example, when our endpoint is accessed, the set of columns to order on is also passed using the `order` and `columns` arrays, which we do not cover in this scenario. If you have time, try to add additional code to support these incoming parameters and order the resulting records accordingly!
  tabs:
  - title: Terminal 1
    type: terminal
    hostname: crc
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root/projects/rhoar-getting-started/quarkus/panache
  difficulty: basic
  timelimit: 500
checksum: "804936652321744277"
