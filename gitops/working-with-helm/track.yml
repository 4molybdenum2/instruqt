challenges:
- assignment: "Welcome! In this section we will be exploring the native Helm integration\n\
    within Argo CD.\n\n## Background\n\nHelm has become the defacto way of packaging\
    \ up and deploying application\nstacks on Kubernetes. You can think of Helm as\
    \ sort of a package manager\nfor Kubernetes. The main components of Helm are:\n\
    \n* `Chart` a package consisting of related Kubernetes YAML files used to deploy\
    \ something (Application/Application Stack/etc).\n* `Repository` a place where\
    \ Charts can be stored, shared and distributed.\n* `Release` a specific instance\
    \ of a Chart deployed on a Kubernetes cluster.\n\nHelm works by the user providing\
    \ parameters (most of the time via a YAML\nfile) against a Helm chart via the\
    \ CLI. These parameters get injected\ninto the Helm template YAML to produce a\
    \ consumable YAML that us deployed\nto the Kubernetes cluster.\n\n![helm-overview](https://katacoda.com/openshift/assets/gitops/helm-overview.png)\n\
    \nArgo CD has native support for Helm built in. You can directly\ncall a Helm\
    \ chart repo and provide the values directly in the\n[Application](https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#applications)\n\
    manifest. Furthermore, you can interact and manage the Helm release on\nyour cluster\
    \ directly with Argo CD via the UI or the CLI.\n\nIn this scenario, we will explore\
    \ how to deploy a Helm chart using the\nnative integration in Argo CD.\n\n## Exploring\
    \ Manifests\n\nYou can specify your Helm repo, chart, and values directly in the\n\
    `Application` manfiest for Argo CD. Let's take a look at the example\nwe're going\
    \ to deploy. `openshift-gitops-examples/components/applications/quarkus-app.yaml`{{open}}\n\
    \nThis `Application` deploys a sample Quarkus application. If you take\na look\
    \ at the file, you can see the specific configuration under\n`.spec.source.helm`.\
    \ Let's take a look at this section/snippet of\nthe YAML:\n\n```yaml\nspec:\n\
    \  source:\n    helm:\n      parameters:\n        - name: build.enabled\n    \
    \      value: \"false\"\n        - name: deploy.route.tls.enabled\n          value:\
    \ \"true\"\n        - name: image.name\n          value: quay.io/ablock/gitops-helm-quarkus\n\
    \    chart: quarkus\n    repoURL: https://redhat-developer.github.io/redhat-helm-charts\n\
    \    targetRevision: 0.0.3\n```\n\nLet's break this `.spec.source.helm` section\
    \ down a bit:\n\n* `parameters` - This section is where you'll enter the parameters\
    \ you want to pass to the Helm chart. These are the same values that you'd have\
    \ in your `Values.yaml` file.\n* `chart` - This is the name of the chart you want\
    \ to deploy from the Helm Repository.\n* `repoURL` - This is the URL of the Helm\
    \ Repository.\n* `targetRevision` - This is the version of the chart you want\
    \ to deploy.\n\nThis can be used to deploy the Helm chart on to your cluster,\
    \ which is like using `helm install ...`.\n\n> **NOTE** What actually happens\
    \ is that Argo CD\n> runs a `helm template ... | kubectl apply -f -`. We'll go\
    \ over that\n> a little later\n\n\n## Deploying The Application\n\nBefore we deploy\
    \ this application, make sure you've opened the Argo CD\nWeb Console.\n\nTo get\
    \ to the Argo CD Web UI; click the [Argo CD Web Console](https://openshift-gitops-server-openshift-gitops.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com)\
    \ tab.\n\nOnce you have accepted the self signed certificate, you should be\n\
    presented with the Argo CD login screen.\n\n![ArgoCD Login](https://katacoda.com/openshift/assets/gitops/argocd-login.png)\n\
    \nYou can login with the following\n* **Username:** ``admin``\n* **Password:**\
    \ ```\noc extract secret/openshift-gitops-cluster -n openshift-gitops --to=-\n\
    ```\n\nApply the Argo CD `Application` manifest to get this Helm chart deployed.\n\
    \n```\noc apply -f ~/resources/openshift-gitops-examples/components/applications/quarkus-app.yaml\n\
    ```\n\nThis should create the `quarkus-app` application. Note the Helm icon\n\u2388\
    \ denoting it's a Helm application.\n\n![quarkus-app](https://katacoda.com/openshift/assets/gitops/quarkus-app.png)\n\
    \nClicking on this \"card\" will take you to the application overview\npage. Clicking\
    \ on \"show hidden resources\" should expand the \"tree\"\nview.\n\n![quarkus-app-tree](https://katacoda.com/openshift/assets/gitops/quarkus-app-tree.png)\n\
    \nGrab the URL by running the following command: ```\noc get route/quarkus-app\
    \ -n demo  -o jsonpath='{.spec.host}{\"\\n\"}'\n```\n\nIf you visit [that URL](https://quarkus-app-demo.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com),\
    \ you should see the following page.\n          \n\n![gitops-loves-helm](https://katacoda.com/openshift/assets/gitops/gitops-loves-helm.png)\n\
    \nYou can now interact with this `Application` using the `argocd` CLI. For instance;\
    \ if I want to change the scale of my application to 2 replicas, I just modify\
    \ that value using the `argocd` CLI.\n\nFirst, check to see how many pods you\
    \ have running: ```\noc get pods -n demo\n```\n\nThe output should look like this.\n\
    \n```shell\nNAME                           READY   STATUS              RESTARTS\
    \   AGE\nquarkus-app-58f475cb86-rddz2   1/1     Running             0        \
    \  14m\n```\n\nNow, modfy the Helm values: ```\nargocd app set quarkus-app -p\
    \ deploy.replicas=2\n```\n\nYou should now have 2 pods for this ```\nApplication`:\
    \ `oc get pods -n demo\n```\n\nThere will now be two pods.\n\n```shell\nNAME \
    \                          READY   STATUS              RESTARTS   AGE\nquarkus-app-58f475cb86-rddz2\
    \   1/1     Running             0          15m\nquarkus-app-58f475cb86-s9llq \
    \  0/1     ContainerCreating   0          1s\n```\n\nThe Argo CD UI should show\
    \ the application with 2 pods and fully healthy/in sync.\n\n![quarkus-2-pods](https://katacoda.com/openshift/assets/gitops/quarkus-2-pods.png)\n\
    \nThis is a valid, and completely supported way of deploying your Helm\ncharts\
    \ using Argo CD. But this isn't GitOps friendly. Lets see how we\ncan use Helm\
    \ in a GitOps workflow.\n\nKeep the Argo CD WebUI tab open for the next exercise,\
    \ where we'll\nexplore a more GitOps friendly way of deploying Helm charts."
  difficulty: basic
  slug: 01-helm-integration
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Helm Integration
  type: challenge
- assignment: "In this section, we will be exporting GitOps deployment patterns with\n\
    Helm!\n\n## Background\n\nIn the previous section, you saw how you can deploy\
    \ a Helm chart\nnatively with Argo CD. This method had you providing the Helm\
    \ Repo,\nChart, and Values directly in the config. Before, it was mentioned that,\
    \ although\nvalid, it's not GitOps friendly.\n\nIn a GitOps workflow, the state\
    \ of your application deployment must be\nstored in a SCM repo (like GitHub).\
    \ In order to do this you must save the\n`values.yaml` in a git repo and reference\
    \ the Helm repo somehow.\n\nThis is where the [Helm Subchart/Dependency](https://github.com/argoproj/argocd-example-apps/blob/master/helm-dependency/README.md)\n\
    deployment strategy comes in.\n\n## Exploring Manifests\n\nWe will be using the\
    \ [examples repo](https://github.com/redhat-developer-demos/openshift-gitops-examples)\
    \ for this and we will be targeting the [quarkus-subchart](https://github.com/redhat-developer-demos/openshift-gitops-examples/tree/main/apps/quarkus-subchart)\
    \ directory. This has already been cloned into your environment you can take a\
    \ look at it by running:\n\n```\ntree ~/resources/openshift-gitops-examples/apps/quarkus-subchart\n\
    ```\n\nThis should have the following output.\n\n```shell\nopenshift-gitops-examples/apps/quarkus-subchart\n\
    \u251C\u2500\u2500 Chart.yaml\n\u2514\u2500\u2500 values.yaml\n\n0 directories,\
    \ 2 files\n```\n\nAs you can see, this is made up of only two YAML files. The\
    \ `Chart.yaml` file and the `values.yaml` file. Take a look at the chart file:\n\
    \n`openshift-gitops-examples/apps/quarkus-subchart/Chart.yaml`{{open}}\n\nThis\
    \ `Chart.yaml` file, is creating an \"empty\" Helm chart and adding the Helm chart\
    \ you want to deploy as a dependency in the `dependecies` secion.\n\n> **NOTE**\
    \ You can deploy more than one Helm chart using this method.\n\nThe next file\
    \ is the `values.yaml` file. Take a look at that file.\n\n`openshift-gitops-examples/apps/quarkus-subchart/values.yaml`{{open}}\n\
    \nHere you're specifying the values you want to pass to the Helm chart.\n\nThis\
    \ is more GitOps friendly as now the state of your deployment is\nstored in a\
    \ git repo. You can now use git workflows to update this\napplication if, for\
    \ example, you want to change the image or the number of\nreplicas. You can now\
    \ PR into this repo as you would in a GitOps workflow.\n\nThe Argo CD `Application`\
    \ should look like a \"normal\" `git` application.\n\n`openshift-gitops-examples/components/applications/quarkus-subchart.yaml`{{open}}\n\
    \nIn this snippet, you can see that now we're targeting the git repo instead of\
    \ the Helm repo.\n\n```yaml\n  source:\n    path: apps/quarkus-subchart/\n   \
    \ repoURL: https://github.com/redhat-developer-demos/openshift-gitops-examples\n\
    \    targetRevision: main\n```\n\nLet's deploy this application!\n\n## Deploying\
    \ The Application\n\nBefore we deploy this application, make sure you've opened\
    \ the Argo CD\nWeb Console.\n\nLike in the previous Step, open the Argo CD Web\
    \ UI by clicking the [Argo CD Web Console](https://openshift-gitops-server-openshift-gitops.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com)\
    \ tab.\n\nApply the Argo CD `Application` manifest to get this Helm chart deployed.\n\
    \n```\noc apply -f ~/resources/openshift-gitops-examples/components/applications/quarkus-subchart.yaml\n\
    ```\n\nThis should create the application.\n\n> **NOTE** The Helm logo \u2388\
    \ does not appear. It's now a git logo since we're now just loading YAML\n\n![quarkus-subchart-app](https://katacoda.com/openshift/assets/gitops/quarkus-subchart-app.png)\n\
    \nClicking on this \"card\" will take you to the application overview\npage. Click\
    \ on \"show hidden resources\" if you need to, to expand the\n\"tree\" view.\n\
    \n![quarkus-subchart-app-tree](https://katacoda.com/openshift/assets/gitops/quarkus-subchart-app-tree.png)\n\
    \nThat's it! You've now deployed a Helm chart in a GitOps friendly way\nusing\
    \ Argo CD!\n\nThere is one important thing to note. We've deployed this Helm chart\n\
    twice, and you can see this using the argocd CLI:\n\n```\nargocd app list -o name\n\
    ```\n\nThis should have the following output:\n\n```shell\nquarkus-app\nquarkus-subchart\n\
    ```\n\nYou can also see this on the cluster itself:\n\n```\noc get applications\
    \ -n openshift-gitops\n```\n\nThis should have an output similar to this.\n\n\
    ```shell\nNAME               SYNC STATUS   HEALTH STATUS\nquarkus-app        Synced\
    \        Healthy\nquarkus-subchart   Synced        Healthy\n```\n\nHowever, when\
    \ you try and list the applications using the Helm CLI; you don't see it.\n\n\
    ```\nhelm ls --all-namespaces\n```\n\nThis should show no Helm releases.\n\n```shell\n\
    NAME    NAMESPACE       REVISION        UPDATED STATUS  CHART   APP VERSION\n\n\
    ```\n\nThis is because of how Argo CD deploys the Helm charts. When Argo CD\n\
    deploys a Helm chart, it deploys it by running `helm template` and\npiping that\
    \ into `kubectl apply -f`. Which means that Argo CD converts\nHelm templates (with\
    \ the values provided) into \"raw\", Kubernetes YAML.\n"
  difficulty: basic
  slug: 02-helm-gitops
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: web-ui
    type: service
  timelimit: 300
  title: Helm GitOps Deployment
  type: challenge
description: '## Goal


  This scenario will get you get familiar with how to use Argo CD to deploy

  Helm charts.



  ## Concepts


  [Helm](https://helm.sh/) is a package manager for Kubernetes

  applications. You can define, install, and update your pre-packaged

  applications. This is a way to bundle up, and deliver prebuilt Kubernetes

  applications.



  ![Helm Logo](../../assets/gitops/helm-logo.png)


  [Argo CD](https://argoproj.github.io/argo-cd/) is a declarative, GitOps continuous
  delivery tool for Kubernetes.


  Using Argo CD, you can still use your Helm charts to deploy and manage your Applications.


  ## Use case


  This is a simple guide that takes you through the following steps:


  * Use the native Helm integration in Argo CD

  * Explore a more GitOps friendly approach to Helm chart deployments


  This OpenShift cluster will self-destruct in one hour.

  '
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: openshift
private: true
published: false
skipping_enabled: false
slug: working-with-helm
tags:
- openshift
title: Working with Helm
type: track
