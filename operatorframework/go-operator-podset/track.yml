challenges:
- assignment: 'Let''s begin by creating a new project called `myproject`:


    ```

    oc new-project myproject

    ```


    ```

    <br>

    Let''s now create a new directory for our project:


    ```

    mkdir -p $HOME/projects/podset-operator

    ```


    ```

    <br>

    Navigate to the directory:


    ```

    cd $HOME/projects/podset-operator

    ```


    ```

    <br>

    Initialize a new Go-based Operator SDK project for the PodSet Operator:


    ```

    operator-sdk init --domain=example.com --repo=github.com/redhat/podset-operator

    ```


    ```'
  difficulty: basic
  slug: step1
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Creating a New Project
  type: challenge
- assignment: 'Add a new Custom Resource Definition (CRD) API called PodSet with APIVersion
    `app.example.com/v1alpha1` and Kind `PodSet`. This command will also create our
    boilerplate controller logic and [Kustomize](https://kustomize.io) configuration
    files.


    ```

    operator-sdk create api --group=app --version=v1alpha1 --kind=PodSet --resource
    --controller

    ```


    ```

    <br>

    We should now see the `/api`, `config`, and `/controllers` directories.'
  difficulty: basic
  slug: step2
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Creating the API and Controller
  type: challenge
- assignment: "Let's begin by inspecting the newly generated `api/v1alpha1/podset_types.go`\
    \ file for our PodSet API:\n\n```\ncat api/v1alpha1/podset_types.go\n```\n\n```\n\
    \nIn Kubernetes, every functional object (with some exceptions, i.e. ConfigMap)\
    \ includes `spec` and `status`. Kubernetes functions by reconciling desired state\
    \ (Spec) with the actual cluster state. We then record what is observed (Status).\
    \ \n\nAlso observe the `+kubebuilder` comment markers found throughout the file.\
    \ `operator-sdk` makes use of a tool called [controler-gen](https://github.com/kubernetes-sigs/controller-tools)\
    \ (from the [controller-tools](https://github.com/kubernetes-sigs/controller-tools)\
    \ project) for generating utility code and Kubernetes YAML. More information on\
    \ markers for config/code generation can be found [here](https://book.kubebuilder.io/reference/markers.html).\n\
    \nLet's now modify the `PodSetSpec` and `PodSetStatus` of the `PodSet` Custom\
    \ Resource (CR) at `api/v1alpha1/podset_types.go`\n\n<br>\nIt should look like\
    \ the file below:\n\n<pre class=\"file\">\npackage v1alpha1\n\nimport (\n    \
    \    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// EDIT THIS FILE!\
    \  THIS IS SCAFFOLDING FOR YOU TO OWN!\n// NOTE: json tags are required.  Any\
    \ new fields you add must have json tags for the fields to be serialized.\n\n\
    // PodSetSpec defines the desired state of PodSet\ntype PodSetSpec struct {\n\
    \        // Replicas is the desired number of pods for the PodSet\n        //\
    \ +kubebuilder:validation:Minimum=1\n        // +kubebuilder:validation:Maximum=10\n\
    \        Replicas int32 `json:\"replicas,omitempty\"`\n}\n\n// PodSetStatus defines\
    \ the current status of PodSet\ntype PodSetStatus struct {\n        PodNames \
    \       []string        `json:\"podNames\"`\n\tAvailableReplicas\tint32\t`json:\"\
    availableReplicas\"`\n}\n\n// +kubebuilder:object:root=true\n// +kubebuilder:subresource:status\n\
    \n// PodSet is the Schema for the podsets API\n// +kubebuilder:printcolumn:JSONPath=\"\
    .spec.replicas\",name=Desired,type=string\n// +kubebuilder:printcolumn:JSONPath=\"\
    .status.availableReplicas\",name=Available,type=string\ntype PodSet struct {\n\
    \        metav1.TypeMeta   `json:\",inline\"`\n        metav1.ObjectMeta `json:\"\
    metadata,omitempty\"`\n\n        Spec   PodSetSpec   `json:\"spec,omitempty\"\
    `\n        Status PodSetStatus `json:\"status,omitempty\"`\n}\n\n// +kubebuilder:object:root=true\n\
    \n// PodSetList contains a list of PodSet\ntype PodSetList struct {\n        metav1.TypeMeta\
    \ `json:\",inline\"`\n        metav1.ListMeta `json:\"metadata,omitempty\"`\n\
    \        Items           []PodSet `json:\"items\"`\n}\n\nfunc init() {\n     \
    \   SchemeBuilder.Register(&PodSet{}, &PodSetList{})\n}\n</pre>\n\nYou can easily\
    \ update this file by running the following command:\n\n```\n\\cp /tmp/podset_types.go\
    \ api/v1alpha1/podset_types.go\n```\n\n```\n<br>\nAfter modifying the `*_types.go`\
    \ file, always run the following command to update the `zz_generated.deepcopy.go`\
    \ file:\n\n```\nmake generate\n```\n\n```\n<br>\nNow we can run the `make manifests`\
    \ command to generate our customized CRD and additional object YAMLs.\n\n```\n\
    make manifests\n```\n\n```\n<br>\nThanks to our comment markers, observe that\
    \ we now have a newly generated CRD yaml that reflects the `spec.replicas` and\
    \ `status.podNames` OpenAPI v3 schema validation and customized print columns.\n\
    \n```\ncat config/crd/bases/app.example.com_podsets.yaml\n```\n\n```\n<br>\nDeploy\
    \ your PodSet Custom Resource Definition to the live OpenShift Cluster:\n\n```\n\
    oc apply -f config/crd/bases/app.example.com_podsets.yaml\n```\n\n```\n<br>\n\
    Confirm the CRD was successfully created:\n\n```\noc get crd podsets.app.example.com\
    \ -o yaml\n```\n\n```\n"
  difficulty: basic
  slug: step3
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Defining the Spec and Status
  type: challenge
- assignment: "Let's now observe the default `controllers/podset_controller.go` file:\n\
    \n```\ncat controllers/podset_controller.go\n```\n\n```\n\nThis default controller\
    \ requires additional logic so we can trigger our reconciler whenever `kind: PodSet`\
    \ objects are added, updated, or deleted. We also want to trigger the reconciler\
    \ whenever Pods owned by a given PodSet are added, updated, and deleted as well.\
    \ To accomplish this. we modify the controller's `SetupWithManager` method. \n\
    \nModify the PodSet controller logic at `controllers/podset_controller.go`:\n\n\
    <pre class=\"file\">\n/*\nCopyright 2021.\n\nLicensed under the Apache License,\
    \ Version 2.0 (the \"License\");\nyou may not use this file except in compliance\
    \ with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\
    \nUnless required by applicable law or agreed to in writing, software\ndistributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the\
    \ specific language governing permissions and\nlimitations under the License.\n\
    */\n\npackage controllers\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\n\t\"k8s.io/apimachinery/pkg/runtime\"\
    \n\tctrl \"sigs.k8s.io/controller-runtime\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\
    \n\tctrllog \"sigs.k8s.io/controller-runtime/pkg/log\"\n\n\tappv1alpha1 \"github.com/redhat/podset-operator/api/v1alpha1\"\
    \n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\
    \n\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\
    \n\t\"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil\"\n)\n\n//\
    \ PodSetReconciler reconciles a PodSet object\ntype PodSetReconciler struct {\n\
    \tclient.Client\n\tScheme *runtime.Scheme\n}\n\n//+kubebuilder:rbac:groups=app.example.com,resources=podsets,verbs=get;list;watch;create;update;patch;delete\n\
    //+kubebuilder:rbac:groups=app.example.com,resources=podsets/status,verbs=get;update;patch\n\
    //+kubebuilder:rbac:groups=app.example.com,resources=podsets/finalizers,verbs=update\n\
    \n// Reconcile is part of the main kubernetes reconciliation loop which aims to\n\
    // move the current state of the cluster closer to the desired state.\n// TODO(user):\
    \ Modify the Reconcile function to compare the state specified by\n// the PodSet\
    \ object against the actual cluster state, and then\n// perform operations to\
    \ make the cluster state reflect the state specified by\n// the user.\n//\n//\
    \ For more details, check Reconcile and its Result here:\n// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile\n\
    func (r *PodSetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result,\
    \ error) {\n\tlog := ctrllog.FromContext(ctx)\n\n\t// Fetch the PodSet instance\n\
    \tinstance := &appv1alpha1.PodSet{}\n\terr := r.Get(context.TODO(), req.NamespacedName,\
    \ instance)\n\tif err != nil {\n\t\tif errors.IsNotFound(err) {\n\t\t\t// Request\
    \ object not found, could have been deleted after reconcile request.\n\t\t\t//\
    \ Owned objects are automatically garbage collected. For additional cleanup logic\
    \ use finalizers.\n\t\t\t// Return and don't requeue\n\t\t\treturn ctrl.Result{},\
    \ nil\n\t\t}\n\t\t// Error reading the object - requeue the request.\n\t\treturn\
    \ ctrl.Result{}, err\n\n\t}\n\n\t// List all pods owned by this PodSet instance\n\
    \tpodSet := instance\n\tpodList := &corev1.PodList{}\n\tlbs := map[string]string{\n\
    \t\t\"app\":     podSet.Name,\n\t\t\"version\": \"v0.1\",\n\t}\n\tlabelSelector\
    \ := labels.SelectorFromSet(lbs)\n\tlistOps := &client.ListOptions{Namespace:\
    \ podSet.Namespace, LabelSelector: labelSelector}\n\tif err = r.List(context.TODO(),\
    \ podList, listOps); err != nil {\n\t\treturn ctrl.Result{}, err\n\t}\n\n\t//\
    \ Count the pods that are pending or running as available\n\tvar available []corev1.Pod\n\
    \tfor _, pod := range podList.Items {\n\t\tif pod.ObjectMeta.DeletionTimestamp\
    \ != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif pod.Status.Phase == corev1.PodRunning\
    \ || pod.Status.Phase == corev1.PodPending {\n\t\t\tavailable = append(available,\
    \ pod)\n\t\t}\n\t}\n\tnumAvailable := int32(len(available))\n\tavailableNames\
    \ := []string{}\n\tfor _, pod := range available {\n\t\tavailableNames = append(availableNames,\
    \ pod.ObjectMeta.Name)\n\t}\n\n\t// Update the status if necessary\n\tstatus :=\
    \ appv1alpha1.PodSetStatus{\n\t\tPodNames:          availableNames,\n\t\tAvailableReplicas:\
    \ numAvailable,\n\t}\n\tif !reflect.DeepEqual(podSet.Status, status) {\n\t\tpodSet.Status\
    \ = status\n\t\terr = r.Status().Update(context.TODO(), podSet)\n\t\tif err !=\
    \ nil {\n\t\t\tlog.Error(err, \"Failed to update PodSet status\")\n\t\t\treturn\
    \ ctrl.Result{}, err\n\t\t}\n\t}\n\n\tif numAvailable > podSet.Spec.Replicas {\n\
    \t\tlog.Info(\"Scaling down pods\", \"Currently available\", numAvailable, \"\
    Required replicas\", podSet.Spec.Replicas)\n\t\tdiff := numAvailable - podSet.Spec.Replicas\n\
    \t\tdpods := available[:diff]\n\t\tfor _, dpod := range dpods {\n\t\t\terr = r.Delete(context.TODO(),\
    \ &dpod)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err, \"Failed to delete pod\"\
    , \"pod.name\", dpod.Name)\n\t\t\t\treturn ctrl.Result{}, err\n\t\t\t}\n\t\t}\n\
    \t\treturn ctrl.Result{Requeue: true}, nil\n\t}\n\n\tif numAvailable < podSet.Spec.Replicas\
    \ {\n\t\tlog.Info(\"Scaling up pods\", \"Currently available\", numAvailable,\
    \ \"Required replicas\", podSet.Spec.Replicas)\n\t\t// Define a new Pod object\n\
    \t\tpod := newPodForCR(podSet)\n\t\t// Set PodSet instance as the owner and controller\n\
    \t\tif err := controllerutil.SetControllerReference(podSet, pod, r.Scheme); err\
    \ != nil {\n\t\t\treturn ctrl.Result{}, err\n\t\t}\n\t\terr = r.Create(context.TODO(),\
    \ pod)\n\t\tif err != nil {\n\t\t\tlog.Error(err, \"Failed to create pod\", \"\
    pod.name\", pod.Name)\n\t\t\treturn ctrl.Result{}, err\n\t\t}\n\t\treturn ctrl.Result{Requeue:\
    \ true}, nil\n\t}\n\n\treturn ctrl.Result{}, nil\n}\n\n// newPodForCR returns\
    \ a busybox pod with the same name/namespace as the cr\nfunc newPodForCR(cr *appv1alpha1.PodSet)\
    \ *corev1.Pod {\n\tlabels := map[string]string{\n\t\t\"app\":     cr.Name,\n\t\
    \t\"version\": \"v0.1\",\n\t}\n\treturn &corev1.Pod{\n\t\tObjectMeta: metav1.ObjectMeta{\n\
    \t\t\tGenerateName: cr.Name + \"-pod\",\n\t\t\tNamespace:    cr.Namespace,\n\t\
    \t\tLabels:       labels,\n\t\t},\n\t\tSpec: corev1.PodSpec{\n\t\t\tContainers:\
    \ []corev1.Container{\n\t\t\t\t{\n\t\t\t\t\tName:    \"busybox\",\n\t\t\t\t\t\
    Image:   \"busybox\",\n\t\t\t\t\tCommand: []string{\"sleep\", \"3600\"},\n\t\t\
    \t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\n// SetupWithManager sets up the controller\
    \ with the Manager.\nfunc (r *PodSetReconciler) SetupWithManager(mgr ctrl.Manager)\
    \ error {\n\treturn ctrl.NewControllerManagedBy(mgr).\n\t\tFor(&appv1alpha1.PodSet{}).\n\
    \t\tOwns(&corev1.Pod{}).\n\t\tComplete(r)\n}\n</pre>\n\nYou can easily update\
    \ this file by running the following command:\n\n```\n\\cp /tmp/podset_controller.go\
    \ controllers/podset_controller.go\n```\n\n```\n\n`go mod tidy`  ensures that\
    \ the go.mod file matches the source code in the module. It adds any missing module\
    \ requirements necessary to build the current module's packages and dependencies,\
    \ and it removes requirements on modules that don't provide any relevant packages.\
    \ It also adds any missing entries to go.sum and removes unnecessary entries.\n\
    \n```\ngo mod tidy\n```\n\n```\n\n"
  difficulty: basic
  slug: step4
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Customizing the Operator Logic
  type: challenge
- assignment: 'Once the CRD is registered, there are two ways to run the Operator:


    * As a Pod inside a Kubernetes cluster

    * As a Go program outside the cluster using Operator-SDK. This is great for local
    development of your Operator.


    For the sake of this tutorial, we will run the Operator as a Go program outside
    the cluster using Operator-SDK and our `kubeconfig` credentials


    Once running, the command will block the current session. You can continue interacting
    with the OpenShift cluster by opening a new terminal window. You can quit the
    session by pressing `CTRL + C`.


    ```

    WATCH_NAMESPACE=myproject make run

    ```


    ```'
  difficulty: basic
  slug: step5
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Running the Operator Locally (Outside the Cluster)
  type: challenge
- assignment: "In a new terminal, inspect the Custom Resource manifest:\n\n```\ncd\
    \ $HOME/projects/podset-operator\ncat config/samples/app_v1alpha1_podset.yaml\n\
    ```\n\n```\n<br>\nEnsure your `kind: PodSet` Custom Resource (CR) is updated with\
    \ `spec.replicas`\n\n<pre class=\"file\">\napiVersion: app.example.com/v1alpha1\n\
    kind: PodSet\nmetadata:\n  name: podset-sample\nspec:\n  replicas: 3\n</pre>\n\
    \nYou can easily update this file by running the following command:\n\n```\n\\\
    cp /tmp/app_v1alpha1_podset.yaml config/samples/app_v1alpha1_podset.yaml\n```\n\
    \n```\n<br>\nEnsure you are currently scoped to the `myproject` Namespace:\n\n\
    ```\noc project myproject\n```\n\n```\n<br>\nDeploy your PodSet Custom Resource\
    \ to the live OpenShift Cluster:\n\n```\noc create -f config/samples/app_v1alpha1_podset.yaml\n\
    ```\n\n```\n<br>\nVerify the Podset exists:\n\n```\noc get podset\n```\n\n```\n\
    <br>\nVerify the PodSet operator has created 3 pods:\n\n```\noc get pods\n```\n\
    \n```\n<br>\nVerify that status shows the name of the pods currently owned by\
    \ the PodSet:\n\n```\noc get podset podset-sample -o yaml\n```\n\n```\n<br>\n\
    Increase the number of replicas owned by the PodSet:\n\n```\noc patch podset podset-sample\
    \ --type='json' -p '[{\"op\": \"replace\", \"path\": \"/spec/replicas\", \"value\"\
    :5}]'\n```\n\n```\n<br>\n\nVerify that we now have 5 running pods\n```\noc get\
    \ pods\n```\n\n```\n"
  difficulty: basic
  slug: step6
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Creating the PodSet Custom Resource
  type: challenge
- assignment: 'Our PodSet controller creates pods containing OwnerReferences in their
    `metadata` section. This ensures they will be removed upon deletion of the `podset-sample`
    CR.


    Observe the OwnerReference set on a Podset''s pod:


    ```

    oc get pods -o yaml | grep ownerReferences -A10

    ```


    ```

    <br>

    Delete the podset-sample Custom Resource:


    ```

    oc delete podset podset-sample

    ```


    ```


    Thanks to OwnerReferences, all of the pods should be deleted:


    ```

    oc get pods

    ```


    ```'
  difficulty: basic
  slug: step7
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Deleting the PodSet Custom Resource
  type: challenge
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner:
- openshift
private: 'false'
published: 'true'
skipping_enabled: 'true'
slug: go-operator-podset
tags:
- openshift
title: Operator SDK with Go
type: truck
