challenges:
- assignment: "Before we get started, you need to login and create a project in OpenShift\n\
    to work in.\n\nTo login to the OpenShift cluster used for this course from the\
    \ _Terminal_,\nrun:\n\n```\noc login -u developer -p developer\n```\n\nThis will\
    \ log you in using the credentials:\n\n* **Username:** ``developer``\n* **Password:**\
    \ ``developer``\n\nYou should see the output:\n\n```\nLogin successful.\n\nYou\
    \ don't have any projects. You can try to create a new project, by running\n\n\
    \    oc new-project <projectname>\n```\n\nTo create a new project called ``myproject``\
    \ run the command:\n\n```\noc new-project myproject\n```\n\nYou should see output\
    \ similar to:\n\n```\nNow using project \"myproject\" on server \"https://openshift:6443\"\
    .\n\nYou can add applications to this project with the 'new-app' command. For\
    \ example, try:\n\n    oc new-app django-psql-example\n\nto build a new example\
    \ application in Python. Or use kubectl to deploy a simple Kubernetes application:\n\
    \n    kubectl create deployment hello-node --image=gcr.io/hello-minikube-zero-install/hello-node\n\
    ```\n\nSwitch to the _Console_ and login to the OpenShift web console using the\n\
    same credentials you used above.\n\n![Web Console Login](https://katacoda.com/openshift/assets/introduction/deploying-python-44/01-web-console-login.png)\n\
    \nThis should leave you at the list of projects you have access to. As we only\n\
    created the one project, all you should see is ``myproject``.\n\n![List of Projects](https://katacoda.com/openshift/assets/introduction/deploying-python-44/01-list-of-projects.png)\n\
    \nClick on ``myproject`` and you should then be at the _Overview_ page for\nthe\
    \ project. Select the _Developer_ perspective for the project instead of the _Adminstrator_\
    \ perspective in the left hand side menu. If necessary click on the hamburger\
    \ menu icon top left of the web console to expose the left hand side menu.\n\n\
    ![Add to Project](https://katacoda.com/openshift/assets/introduction/deploying-images-44/01-add-to-project.png)\n\
    \n\nAs the project is currently empty, no workloads should be found and you will\
    \ be presented with various options for how you can deploy an application.\n"
  difficulty: basic
  slug: 01-creating-an-initial-project
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 1 - Creating an Initial Project
  type: challenge
- assignment: 'From the options presented for deploying an application, select _From
    Catalog_. This will land you on the _Developer Catalog_.


    ![Developer Catalog](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-developer-catalog.png)


    In this course you are going to deploy a web application which is implemented
    using the Python programming language.


    If no items are displayed when you view the _Developer Catalog_, uncheck _Operator
    Backed_ in the _Type_ filters on the left hand side. Click on _Languages_ on the
    left hand side and then select _Python_. Any options for deploying applications
    which are related to Python will be displayed.


    ![Available Python Versions](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-deploy-python-source.png)


    Click on the _Python_ tile for the generic Python Source-to-Image (S2I) builder.
    This will bring up a dialog with the details of the builder image. Click on _Create
    Application_ in the dialog.


    ![Create Python Application #1](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-create-python-application-1.png)


    Under the _Git_ settings, in the _Git Repo URL_ enter:


    `https://github.com/openshift-katacoda/blog-django-py`


    Scroll down to the _General_ settings and click on the _Application Name_ field.


    ![Create Python Application #2](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-create-python-application-2.png)


    When you click on the _Application Name_ field, the settings in this section should
    be pre-populated with values based on the Git repository name. Leave the settings
    with their default values.


    When you are ready, at the bottom of the page click on _Create_. This will create
    resources to manage the build and deployment of the application. You will then
    be redirected to the topology overview for the project.


    ![Application Topology View](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-application-topology-view.png)


    The topology overview provides a visual representation of the application you
    have deployed.


    The Git icon shown to the lower right of the ring can be clicked on to take you
    to the hosted Git repository from which the source code for the application was
    built.


    The icon shown to the lower left represents the build of the application. The
    icon will change from showing an hour glass, indicating the build is starting,
    to a sync icon indicating the build is in progress, and finally to a tick or cross
    depending on whether the build was successful or failed. Clicking on this icon
    will take you to the details of the current build.


    Once the application is running, the icon shown to the upper right can be clicked
    to open the URL for the application route which was created.


    The ring itself will progress from being white, indicating the deployment is pending,
    to light blue indicating the deployment is starting, and blue to indicate the
    application is running. The ring can also turn dark blue if the application is
    stopping.


    Clicking anywhere on the area enclosed by the ring will bring up a panel giving
    details of the resources for the application, and access to a general overview
    of the deployment.


    ![Deployment Details](https://katacoda.com/openshift/assets/introduction/deploying-python-44/02-deployment-details.png)

    '
  difficulty: basic
  slug: 02-deploying-using-the-web-console
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 2 - Deploying Using the Web Console
  type: challenge
- assignment: 'Once the build has started, click on the _View Logs_ link shown on
    the _Resources_ panel.


    ![Accessing Build Logs](https://katacoda.com/openshift/assets/introduction/deploying-python-44/03-application-build-logs.png)


    This will allow you to monitor the progress of the build as it runs. The build
    will have completely successfully when you see a final message of "Push successful".
    This indicates that the container image for the application was pushed to the
    OpenShift internal image registry.

    '
  difficulty: basic
  slug: 03-viewing-the-builder-logs
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 3 - Viewing the Builder Logs
  type: challenge
- assignment: 'Once the build of the application image has completed, it will be deployed.


    Click on _Topology_ in the left hand menu bar to return to the topology view for
    the project.


    ![Topology View](https://katacoda.com/openshift/assets/introduction/deploying-python-44/04-application-topology-view.png)


    When you created the application using the web console, a _Route_ was automatically
    created for the application and it will be exposed outside of the cluster. The
    URL which can be used to access the application from a web browser was visible
    on the _Resources_ tab for the application you viewed previously.


    From the topology view, you can quickly get to the URL for the deployed application
    by clicking on the icon top right of the ring in the visualisation for the application.


    Wait for the ring to turn from light blue to blue to indicate the deployment is
    complete. Now click on the icon and you should see the blog application you deployed.


    ![Blog Web Site](https://katacoda.com/openshift/assets/introduction/deploying-python-44/04-blog-web-site.png)

    '
  difficulty: basic
  slug: 04-accessing-the-application
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 4 - Accessing the Application
  type: challenge
- assignment: "Instead of deploying the application from the web console, you can\
    \ use the command line. Before we do that, lets delete the application we have\
    \ already deployed.\n\nTo do this from the web console you could visit each resource\
    \ type created and delete them one at a time. The simpler way to delete an application\
    \ is from the command line using the ``oc`` command line tool.\n\nTo see a list\
    \ of all the resources that have been created in the project so far, you can run\
    \ the command:\n\n```\noc get all -o name\n```\n\nThis will display output similar\
    \ to:\n\n```\npod/blog-django-py-1-build\npod/blog-django-py-64fb76b5c9-6hzhn\n\
    service/blog-django-py\ndeployment.apps/blog-django-py\nreplicaset.apps/blog-django-py-64fb76b5c9\n\
    replicaset.apps/blog-django-py-6c7f488b57\nbuildconfig.build.openshift.io/blog-django-py\n\
    build.build.openshift.io/blog-django-py-1\nimagestream.image.openshift.io/blog-django-py\n\
    route.route.openshift.io/blog-django-py\n```\n\nYou have only created one application,\
    \ so you would know that all the resources listed will relate to it. When you\
    \ have multiple applications deployed, you need to identify those which are specific\
    \ to the application you may want to delete. You can do this by applying a command\
    \ to a subset of resources using a label selector.\n\nTo determine what labels\
    \ may have been added to the resources, select one and display the details on\
    \ it. To look at the _Route_ which was created, you can run the command:\n\n```\n\
    oc describe route/blog-django-py\n```\n\nThis should display output similar to:\n\
    \n```\nName:                   blog-django-py\nNamespace:              myproject\n\
    Created:                19 minutes ago\nLabels:                 app=blog-django-py\n\
    \                        app.kubernetes.io/component=blog-django-py\n        \
    \                app.kubernetes.io/instance=blog-django-py\n                 \
    \       app.kubernetes.io/name=python\n                        app.kubernetes.io/part-of=blog-django-py-app\n\
    \                        app.openshift.io/runtime=python\n                   \
    \     app.openshift.io/runtime-version=3.6\nAnnotations:            openshift.io/host.generated=true\n\
    Requested Host:         blog-django-py-myproject.2886795320-80-simba02.environments.katacoda.com\n\
    \                          exposed on router default (host apps-crc.testing) 19\
    \ minutes ago\nPath:                   <none>\nTLS Termination:        <none>\n\
    Insecure Policy:        <none>\nEndpoint Port:          8080-tcp\n\nService: \
    \       blog-django-py\nWeight:         100 (100%)\nEndpoints:      10.128.0.65:8080\n\
    ```\n\nIn this case when deploying the application via the OpenShift web console,\
    \ OpenShift has applied automatically to all resources the label ``app=blog-django-py``.\
    \ You can confirm this by running the command:\n\n```\noc get all --selector app=blog-django-py\
    \ -o name\n```\n\nThis should display the same list of resources as when ``oc\
    \ get all -o name`` was run. To double check that this is doing what is being\
    \ described, run instead:\n\n```\noc get all --selector app=blog -o name\n```\n\
    \nIn this case, because there are no resources with the label ``app=blog``, the\
    \ result will be empty.\n\nHaving a way of selecting just the resources for the\
    \ one application, you can now schedule them for deletion by running the command:\n\
    \n```\noc delete all --selector app=blog-django-py\n```\n\nTo confirm that the\
    \ resources have been deleted, run again the command:\n\n```\noc get all -o name\n\
    ```\n\nIf you do still see any resources listed, keep running this command until\
    \ it shows they have all been deleted. You can find that resources may not be\
    \ deleted immediately as you only scheduled them for deletion and how quickly\
    \ they can be deleted will depend on how quickly the application can be shutdown.\n\
    \nAlthough label selectors can be used to qualify what resources are to be queried,\
    \ or deleted, do be aware that it may not always be the ``app`` label that you\
    \ need to use. When an application is created from a template, the labels applied\
    \ and their names are dictated by the template. As a result, a template may use\
    \ a different labelling convention. Always use ``oc describe`` to verify what\
    \ labels have been applied and use ``oc get all --selector`` to verify what resources\
    \ are matched before deleting any resources.\n"
  difficulty: basic
  slug: 05-deleting-the-application
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 5 - Deleting the Application
  type: challenge
- assignment: "You now have a clean project again, so lets deploy the same web application,\
    \ but this time using the ``oc`` command line tool.\n\nThe URL of the Git repository\
    \ containing the web application is:\n\n`https://github.com/openshift-katacoda/blog-django-py`\n\
    \nWe want to deploy it using the S2I builder for the latest version of Python\
    \ provided by the platform. To do this run the command:\n\n```\noc new-app python:latest~https://github.com/openshift-katacoda/blog-django-py\n\
    ```\n\nThis should display output similar to:\n\n```\n--> Found image 2437334\
    \ (6 weeks old) in image stream \"openshift/python\" under tag \"latest\" for\
    \ \"python:latest\"\n\n    Python 3.6\n    ----------\n    ...\n\n    Tags: builder,\
    \ python, python36, python-36, rh-python36\n\n    * A source build using source\
    \ code from https://github.com/openshift-katacoda/blog-django-py will be created\n\
    \      * The resulting image will be pushed to image stream tag \"blog-django-py:latest\"\
    \n      * Use 'oc start-build' to trigger a new build\n    * This image will be\
    \ deployed in deployment config \"blog-django-py\"\n    * Port 8080/tcp will be\
    \ load balanced by service \"blog-django-py\"\n      * Other containers can access\
    \ this service through the hostname \"blog-django-py\"\n\n--> Creating resources\
    \ ...\n    imagestream.image.openshift.io \"blog-django-py\" created\n    buildconfig.build.openshift.io\
    \ \"blog-django-py\" created\n    deploymentconfig.apps.openshift.io \"blog-django-py\"\
    \ created\n    service \"blog-django-py\" created\n--> Success\n    Build scheduled,\
    \ use 'oc logs -f bc/blog-django-py' to track its progress.\n    Application is\
    \ not exposed. You can expose services to the outside world by executing one or\
    \ more of the commands below:\n     'oc expose svc/blog-django-py'\n    Run 'oc\
    \ status' to view your app.\n```\n\nOpenShift will assign a default name for the\
    \ application created based on the name of the Git repository. In this case that\
    \ is ``blog-django-py``. If you wanted to change the name, you could have supplied\
    \ the ``--name`` option along with the name you wish to use as an argument.\n\n\
    To monitor the log output from the build as it is running, run the command:\n\n\
    ```\noc logs bc/blog-django-py --follow\n```\n\nThis command will exit once the\
    \ build has completed. You can also interrupt the command by typing _CTRL-C_ in\
    \ the terminal window.\n\nTo view the status of any applications deployed to the\
    \ project you can run the command:\n\n```\noc status\n```\n\nOnce the build and\
    \ deployment of the application has completed you should see output similar to:\n\
    \n```\nIn project myproject on server https://openshift:6443\n\nsvc/blog-django-py\
    \ - 172.30.54.158:8080\n  dc/blog-django-py deploys istag/blog-django-py:latest\
    \ <-\n    bc/blog-django-py source builds https://github.com/openshift-katacoda/blog-django-py\
    \ on openshift/python:latest\n    deployment #1 pending 10 seconds ago - 0/1 pods\n\
    \n\n3 infos identified, use 'oc status --suggest' to see details.\n```\n\nUnlike\
    \ the case of deploying the application from the web console, the application\
    \ is not exposed outside of the OpenShift cluster by default. To expose the application\
    \ so it is available outside of the OpenShift cluster, you can run the command:\n\
    \n```\noc expose service/blog-django-py\n```\n\nSwitch to the OpenShift web console\
    \ by selecting on _Console_ to verify that the application has been deployed.\n\
    \nYou will note though that the visualisation on the topology view lacks icons\
    \ for the build and source code repository. This is because they rely on special\
    \ annotations and labels added to the deployment when creating an application\
    \ from the web console. These annotations are not added automatically when creating\
    \ the application from the command line. You can add the annotations later if\
    \ you wanted.\n\nThe icon for accessing the URL is still present on the visualisation.\
    \ Alternatively, to view the hostname assigned to the route created from the command\
    \ line, you can run the command:\n\n```\noc get route/blog-django-py\n```\n"
  difficulty: basic
  slug: 06-deploying-using-the-command-line
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 6 - Deploying Using the Command Line
  type: challenge
- assignment: "The source code for an application isn't going to be static, so a way\
    \ to trigger a new build after making any changes is required.\n\nTo do this from\
    \ the command line using ``oc``, run the command:\n\n```\noc start-build blog-django-py\n\
    ```\n\nThis should display:\n\n```\nbuild.build.openshift.io/blog-django-py-2\
    \ started\n```\n\nA new build could also have been triggered from the web console\
    \ by finding the build configuration for the application under the _Builds_ menu,\
    \ selecting the kebab menu on the right side of the entry, and clicking on _Start\
    \ Build_.\n\nAs before you can use ``oc logs`` to monitor the log output as the\
    \ build runs. You can also monitor the progress of any builds in a project by\
    \ running the command:\n\n```\noc get builds --watch\n```\n\nAs the build progresses,\
    \ this should display output similar to:\n\n```\nNAME                TYPE    \
    \  FROM          STATUS     STARTED         DURATION\nblog-django-py-1    Source\
    \    Git@fcdc38c   Complete   2 minutes ago   1m2s\nblog-django-py-2    Source\
    \    Git@fcdc38c   Running    3 seconds ago   3s\nblog-django-py-2    Source \
    \   Git@fcdc38c   Complete   About a minute ago   1m9s\n```\n\nTo exit the command\
    \ type _CTRL-C_ in the terminal window.\n\nTo display information about the build\
    \ configuration for the application you can run:\n\n```\noc describe bc/blog-django-py\n\
    ```\n\nThis will display output similar to:\n\n```\nName:           blog-django-py\n\
    Namespace:      myproject\nCreated:        8 minutes ago\nLabels:         app=blog-django-py\n\
    Annotations:    openshift.io/generated-by=OpenShiftNewApp\nLatest Version: 2\n\
    \nStrategy:       Source\nURL:            https://github.com/openshift-katacoda/blog-django-py\n\
    From Image:     ImageStreamTag openshift/python:latest\nOutput to:      ImageStreamTag\
    \ blog-django-py:latest\n\nBuild Run Policy:       Serial\nTriggered by:     \
    \      Config, ImageChange\nWebhook GitHub:\n        URL:    https://openshift:6443/apis/build.openshift.io/v1/namespaces/myproject/buildconfigs/blog-django-py/webhooks/<secret>/github\n\
    Webhook Generic:\n        URL:            https://openshift:6443/apis/build.openshift.io/v1/namespaces/myproject/buildconfigs/blog-django-py/webhooks/<secret>/generic\n\
    \        AllowEnv:       false\nBuilds History Limit:\n        Successful:   \
    \  5\n        Failed:         5\n\nBuild                   Status          Duration\
    \        Creation Time\nblog-django-py-2        complete        1m28s        \
    \   2019-11-05 05:19:32 +0000 UTC\nblog-django-py-1        complete        1m31s\
    \           2019-11-05 05:13:21 +0000 UTC\n\nEvents: <none>\n```\n\nYou can see\
    \ details of the Git repository being used as the source for any build.\n\nYou\
    \ will also see listed webhook URLs that can be configured into a Git hosting\
    \ service to trigger a new build automatically when changes are committed and\
    \ pushed up to a Git repository. As you are using a Git repository on GitHub that\
    \ you don't own this can not be done for this exercise, but if you had forked\
    \ the Git repository into your own account, or this was your own application,\
    \ it could have been configured.\n\nThe typical workflow followed when developing\
    \ an application, is to work on your application source code on your own local\
    \ machine. When you are happy with changes and they are ready to be made live,\
    \ commit the changes and push them up to the hosted Git repository linked to the\
    \ build configuration. If a webhook has been configured, a new build and deployment\
    \ would be triggered automatically, otherwise you can trigger a new build manually.\n\
    \nIn the case of where you are rapidly iterating on changes to test ideas and\
    \ don't want to have to commit every change and push it back up to the hosted\
    \ Git repository, you can use what is called a binary input build.\n\nTo demonstrate\
    \ this, clone the Git repository for the application by running:\n\n```\ngit clone\
    \ https://github.com/openshift-katacoda/blog-django-py\n```\n\nThis will create\
    \ a sub directory ``blog-django-py`` containing the source code for the application:\n\
    \n```\nCloning into 'blog-django-py'...\nremote: Enumerating objects: 3, done.\n\
    remote: Counting objects: 100% (3/3), done.\nremote: Compressing objects: 100%\
    \ (3/3), done.\nremote: Total 412 (delta 0), reused 0 (delta 0), pack-reused 409\n\
    Receiving objects: 100% (412/412), 68.49 KiB | 556.00 KiB/s, done.\nResolving\
    \ deltas: 100% (200/200), done.\n```\n\nChange into the sub directory.\n\n```\n\
    cd blog-django-py\n```\n\nTo show how a build can be triggered from the local\
    \ copy of the application source code, without needing to commit changes back\
    \ to the Git repository, first run the command:\n\n```\necho 'BLOG_BANNER_COLOR=blue'\
    \ >> .s2i/environment\n```\n\nThis command will update an environment variable\
    \ setting file used by S2I to determine what environment variables are baked into\
    \ the application image created.\n\nStart a new build by running the command:\n\
    \n```\noc start-build blog-django-py --from-dir=. --wait\n```\n\nThis is similar\
    \ to what you ran before, with the exception that the option ``--from-dir=.``\
    \ is also passed to the command, indicating that source code should be uploaded\
    \ from the directory on the host where you are running the command, rather than\
    \ it being pulled down from the hosted Git repository.\n\nThe output from running\
    \ the command should start with:\n\n```\nUploading directory \".\" as binary input\
    \ for the build ...\n```\n\nindicating that the source code is being uploaded.\n\
    \nThe ``--wait`` option is also supplied to indicate that the command should only\
    \ return when the build has completed. This option can be useful if integrating\
    \ it into a script and you need to ensure the build has completed before running\
    \ a subsequent command.\n\nWhile the build command is running and the application\
    \ is being deployed, switch to the web console to monitor progress. You can find\
    \ the details for the current build by selecting _Builds_ from the left hand side\
    \ menu, selecting on the build configuration for ``blog-django-py``, selecting\
    \ the _Builds_ tab and then clicking on ``blog-django-py-3``.\n\nOnce the build\
    \ and deployment is finished, if you visit the web application once more, you\
    \ will see that the banner colour has been changed to blue.\n\n![Blog Web Site](https://katacoda.com/openshift/assets/introduction/deploying-python-44/07-blog-web-site-blue.png)\n\
    \nWhen you use the ``--from-dir=.`` option with ``oc start-build``, the contents\
    \ from the current working directory will only be used for that one build. If\
    \ you wanted to run further builds with source code from your local directory,\
    \ you would need to supply ``--from-dir=.`` each time.\n\nTo return back to using\
    \ the source code from the hosted Git repository, run:\n\n\n```\noc start-build\
    \ blog-django-py\n```\n\nThis should output:\n\n```\nbuild.build.openshift.io/blog-django-py-4\
    \ started\n```\n\nIf for some reason a build was wrongly started, or you realised\
    \ it would fail anyway, you can cancel the build by running ``oc cancel-build``\
    \ and supplying the name of the build.\n\n```\noc cancel-build blog-django-py-4\n\
    ```\n\nThis should show the build has been cancelled.\n\n```\nbuild.build.openshift.io/blog-django-py-4\
    \ marked for cancellation, waiting to be cancelled\nbuild.build.openshift.io/blog-django-py-4\
    \ cancelled\n```\n\nYou can confirm this by also looking at the list of all builds\
    \ run.\n\n```\noc get builds\n```\n\nThis should display output similar to:\n\n\
    ```\nNAME               TYPE     FROM             STATUS                     \
    \  STARTED          DURATION\nblog-django-py-1   Source   Git@35b89e2      Complete\
    \                     15 minutes ago   1m31s\nblog-django-py-2   Source   Git@35b89e2\
    \      Complete                     8 minutes ago    1m28s\nblog-django-py-3 \
    \  Source   Binary@35b89e2   Complete                     3 minutes ago    1m28s\n\
    blog-django-py-4   Source   Git@35b89e2      Cancelled (CancelledBuild)   31 seconds\
    \ ago   23s\n```\n\nNote that starting a build using source code from a local\
    \ directory on your own machine can only be done from the command line. There\
    \ is no way to trigger such a build from the web console.\n"
  difficulty: basic
  slug: 07-triggering-a-new-build
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  timelimit: 300
  title: Topic 7 - Triggering a New Build
  type: challenge
description: '## Goal


  Learn how to deploy an application from its source code using a [Source-to-Image][s2i]
  build on OpenShift.


  ## Concepts


  * Linux containers and building container images

  * OpenShift Source-to-Image (S2I)

  * OpenShift Projects and Applications

  * OpenShift `oc` command line tool


  ## Use case


  You can have OpenShift build an application from source to deploy it, so you don''t
  have to construct a container by hand with every change. OpenShift can then build
  and deploy new versions automatically when notified of souce code changes.


  This OpenShift cluster will self-destruct in one hour.


  [s2i]: https://docs.openshift.com/container-platform/4.4/builds/understanding-image-builds.html#build-strategy-s2i_understanding-image-builds

  '
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: openshift
private: true
published: false
skipping_enabled: false
slug: developing-on-openshift-deploying-python
tags:
- openshift
title: Deploying Applications From Source
type: track
