challenges:
- assignment: "Before we get started, you need to login and create a project in OpenShift\n\
    to work in.\n\nTo login to the OpenShift cluster used for this course from the\
    \ _Terminal_,\nrun:\n\n```\noc login -u developer -p developer\n```\n\nThis will\
    \ log you in using the credentials:\n\n* **Username:** ``developer``\n* **Password:**\
    \ ``developer``\n\nYou should see the output:\n\n```\nLogin successful.\n\nYou\
    \ don't have any projects. You can try to create a new project, by running\n\n\
    \    oc new-project <projectname>\n```\n\nTo create a new project called ``myproject``\
    \ run the command:\n\n```\noc new-project myproject\n```\n\nYou should see output\
    \ similar to:\n\n```\nNow using project \"myproject\" on server \"https://openshift:6443\"\
    .\n\nYou can add applications to this project with the 'new-app' command. For\
    \ example, try:\n\n    oc new-app django-psql-example\n\nto build a new example\
    \ application in Python. Or use kubectl to deploy a simple Kubernetes application:\n\
    \n    kubectl create deployment hello-node --image=gcr.io/hello-minikube-zero-install/hello-node\n\
    ```\n\nSwitch to the _Console_ and login to the OpenShift web console using the\n\
    same credentials you used above.\n\n![Web Console Login](https://katacoda.com/openshift/assets/introduction/deploying-images-44/01-web-console-login.png)\n\
    \nThis should leave you at the list of projects you have access to. As we only\n\
    created the one project, all you should see is ``myproject``.\n\n![List of Projects](https://katacoda.com/openshift/assets/introduction/deploying-images-44/01-list-of-projects.png)\n\
    \nClick on ``myproject`` and you should then be at the _Overview_ page for\nthe\
    \ project. Select the _Developer_ perspective for the project instead of the _Adminstrator_\
    \ perspective in the left hand side menu. If necessary click on the hamburger\
    \ menu icon top left of the web console to expose the left hand side menu.\n\n\
    As the project is currently empty, no workloads should be found and you will be\
    \ presented with various options for how you can deploy an application.\n\n![Add\
    \ to Project](https://katacoda.com/openshift/assets/introduction/deploying-images-44/01-add-to-project.png)\n"
  difficulty: basic
  slug: 01-creating-an-initial-project
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  - hostname: crc-nonest-1
    path: /root
    title: Visual Editor
    type: code
  timelimit: 300
  title: Topic 1 - Creating an Initial Project
  type: challenge
- assignment: 'On the _Topology_ view, select _Container Image_. This should present
    the option of deploying an image by performing a search for the image on an image
    registry.


    For this example, the application image we are going to deploy is being hosted
    on the Docker Hub Registry.


    In the _Image name from external registry_ field enter:


    ``openshiftkatacoda/blog-django-py``


    Press tab or click outside of the text field. This should trigger a query validate
    the image.


    ![Image Search](https://katacoda.com/openshift/assets/introduction/deploying-images-44/02-image-search.png)


    From the name of the image, the _Application Name_ and deployment _Name_ fields
    will be automatically populated.


    The deployment name is used in OpenShift to identify the resources created when
    the application is deployed. This will include the internal _Service_ name used
    by other applications in the same project to communicate with it, as well as being
    used as part of the default hostname for the application when exposed externally
    to the cluster via a _Route_.


    The _Application Name_ field is used to group multiple deployments together under
    the same name as part of one overall application.


    In this example leave both fields as their default values. For your own application
    you would consider changing these to something more appropriate.


    At the bottom of this page you will see that the checkbox for creating a route
    to the application is selected. This indicates that the application will be automatically
    given a public URL for accessing it. If you did not want the deployment to be
    accessible outside of the cluster, or it was not a web service, you would de-select
    the option.


    When you are ready, at the bottom of the page click on _Create_. This will return
    you to the _Topology_ view, but this time you will see a representation of the
    deployment, rather than the options for deploying an application.


    ![Topology View](https://katacoda.com/openshift/assets/introduction/deploying-images-44/02-topology-view.png)


    You may see the color of the ring in the visualization change from white, to light
    blue and then blue. This represents the phases of deployment as the container
    for the application starts up.

    '
  difficulty: basic
  slug: 02-deploying-using-the-web-console
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  - hostname: crc-nonest-1
    path: /root
    title: Visual Editor
    type: code
  timelimit: 300
  title: Topic 2 - Deploying Using the Web Console
  type: challenge
- assignment: 'To drill down and get further details on the deployment, click in the
    middle of the ring. This will result in a panel sliding out from the right hand
    side providing access to both an _Overview_:


    ![Deployment Overview](https://katacoda.com/openshift/assets/introduction/deploying-images-44/03-deployment-overview.png)


    and details on _Resources_ related to the deployment.


    ![Deployment Resources](https://katacoda.com/openshift/assets/introduction/deploying-images-44/03-deployment-resources.png)


    From the _Overview_ for the deployment, you can adjust the number of replicas,
    or pods, by clicking on the up and down arrows to the right of the ring.


    The public URL for accessing the application can be found under _Resources_.


    If you dismiss the panel, you can also access the application via its public URL,
    by clicking on the URL shortcut icon on the visualization of the deployment.


    ![URL Shortcut Icon](https://katacoda.com/openshift/assets/introduction/deploying-images-44/03-url-shortcut-icon.png)

    '
  difficulty: basic
  slug: 03-exploring-the-topology-view
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  - hostname: crc-nonest-1
    path: /root
    title: Visual Editor
    type: code
  timelimit: 300
  title: Topic 3 - Exploring the Topology View
  type: challenge
- assignment: "Instead of deploying the existing container image from the web console,\
    \ you can use the command line. Before we do that, lets delete the application\
    \ we have already deployed.\n\nTo do this from the web console you could visit\
    \ each resource type created and delete them one at a time. The simpler way to\
    \ delete an application is from the command line using the ``oc`` program.\n\n\
    To see a list of all the resources that have been created in the project so far,\
    \ you can run the command:\n\n```\noc get all -o name\n```\n\nThis will display\
    \ output similar to:\n\n```\npod/blog-django-py-1-cbp96\npod/blog-django-py-1-deploy\n\
    replicationcontroller/blog-django-py-1\nservice/blog-django-py\ndeploymentconfig.apps.openshift.io/blog-django-py\n\
    imagestream.image.openshift.io/blog-django-py\nroute.route.openshift.io/blog-django-py\n\
    ```\n\nYou have only created one application, so you would know that all the resources\
    \ listed will relate to it. When you have multiple applications deployed, you\
    \ need to identify those which are specific to the application you may want to\
    \ delete. You can do this by applying a command to a subset of resources using\
    \ a label selector.\n\nTo determine what labels may have been added to the resources,\
    \ select one and display the details on it. To look at the _Route_ which was created,\
    \ you can run the command:\n\n```\noc describe route/blog-django-py\n```\n\nThis\
    \ should display output similar to:\n\n```\nName:                   blog-django-py\n\
    Namespace:              myproject\nCreated:                2 minutes ago\nLabels:\
    \                 app=blog-django-py\n                        app.kubernetes.io/component=blog-django-py\n\
    \                        app.kubernetes.io/instance=blog-django-py\n         \
    \               app.kubernetes.io/part-of=blog-django-py-app\nAnnotations:   \
    \         openshift.io/generated-by=OpenShiftWebConsole\n                    \
    \    openshift.io/host.generated=true\nRequested Host:         blog-django-py-myproject.2886795274-80-frugo03.environments.katacoda.com\n\
    \                          exposed on router default (host apps-crc.testing) 2\
    \ minutes ago\nPath:                   <none>\nTLS Termination:        <none>\n\
    Insecure Policy:        <none>\nEndpoint Port:          8080-tcp\n\nService: \
    \       blog-django-py\nWeight:         100 (100%)\nEndpoints:      10.128.0.205:8080\n\
    ```\n\nIn this case when deploying the existing container image via the OpenShift\
    \ web console, OpenShift has applied automatically to all resources the label\
    \ ``app=blog-django-py``. You can confirm this by running the command:\n\n```\n\
    oc get all --selector app=blog-django-py -o name\n```\n\nThis should display the\
    \ same list of resources as when ``oc get all -o name`` was run. To double check\
    \ that this is doing what is being described, run instead:\n\n```\noc get all\
    \ --selector app=blog -o name\n```\n\nIn this case, because there are no resources\
    \ with the label ``app=blog``, the result will be empty.\n\nHaving a way of selecting\
    \ just the resources for the one application, you can now schedule them for deletion\
    \ by running the command:\n\n```\noc delete all --selector app=blog-django-py\n\
    ```\n\nTo confirm that the resources have been deleted, run again the command:\n\
    \n```\noc get all -o name\n```\n\nIf you do still see any resources listed, keep\
    \ running this command until it shows they have all been deleted. You can find\
    \ that resources may not be deleted immediately as you only scheduled them for\
    \ deletion and how quickly they can be deleted will depend on how quickly the\
    \ application can be shutdown.\n\nAlthough label selectors can be used to qualify\
    \ what resources are to be queried, or deleted, do be aware that it may not always\
    \ be the ``app`` label that you need to use. When an application is created from\
    \ a template, the labels applied and their names are dictated by the template.\
    \ As a result, a template may use a different labelling convention. Always use\
    \ ``oc describe`` to verify what labels have been applied and use ``oc get all\
    \ --selector`` to verify what resources are matched before deleting any resources.\n"
  difficulty: basic
  slug: 04-deleting-the-application
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  - hostname: crc-nonest-1
    path: /root
    title: Visual Editor
    type: code
  timelimit: 300
  title: Topic 4 - Deleting the Application
  type: challenge
- assignment: "You now have a clean project again, so lets deploy the same existing\
    \ container image, but this time using the ``oc`` command line program.\n\nThe\
    \ name of the image you used previously was:\n\n```\nopenshiftkatacoda/blog-django-py\n\
    ```\n\nIf you have been given the name of an image to deploy and want to verify\
    \ that it is valid from the command line, you can use the ``oc new-app --search``\
    \ command. For this image run:\n\n```\noc new-app --search openshiftkatacoda/blog-django-py\n\
    ```\n\nThis should display output similar to:\n\n```\nDocker images (oc new-app\
    \ --docker-image=<docker-image> [--code=<source>])\n-----\nopenshiftkatacoda/blog-django-py\n\
    \  Registry: Docker Hub\n  Tags:     latest\n```\n\nIt confirms that the image\
    \ is found on the Docker Hub Registry.\n\nTo deploy the image, you can run the\
    \ command:\n\n```\noc new-app openshiftkatacoda/blog-django-py\n```\n\nThis will\
    \ display out similar to:\n\n```\n--> Found container image 927f823 (4 months\
    \ old) from Docker Hub for \"openshiftkatacoda/blog-django-py\"\n\n    Python\
    \ 3.5\n    ----------\n    Python 3.5 available as container is a base platform\
    \ for building and running various Python 3.5 applications and frameworks. Python\
    \ is an easy to learn, powerful programming language. It has efficient high-level\
    \ data structures and a simple but effective approach to object-oriented programming.\
    \ Python's elegant syntax and dynamic typing, together with its interpreted nature,\
    \ make it an ideal language for scripting and rapid application development in\
    \ many areas on most platforms.\n\n    Tags: builder, python, python35, python-35,\
    \ rh-python35\n\n    * An image stream tag will be created as \"blog-django-py:latest\"\
    \ that will track this image\n    * This image will be deployed in deployment\
    \ config \"blog-django-py\"\n    * Port 8080/tcp will be load balanced by service\
    \ \"blog-django-py\"\n      * Other containers can access this service through\
    \ the hostname \"blog-django-py\"\n\n--> Creating resources ...\n    imagestream.image.openshift.io\
    \ \"blog-django-py\" created\n    deploymentconfig.apps.openshift.io \"blog-django-py\"\
    \ created\n    service \"blog-django-py\" created\n--> Success\n    Application\
    \ is not exposed. You can expose services to the outside world by executing one\
    \ or more of the commands below:\n     'oc expose svc/blog-django-py'\n    Run\
    \ 'oc status' to view your app.\n```\n\nOpenShift will assign a default name based\
    \ on the name of the image, in this case ``blog-django-py``. You can specify a\
    \ different name to be given to the application, and the resources created, by\
    \ supplying the ``--name`` option along with the name you wish to use as an argument.\n\
    \nUnlike how it is possible when deploying an existing container image from the\
    \ web console, the application is not exposed outside of the OpenShift cluster\
    \ by default. To expose the application created so it is available outside of\
    \ the OpenShift cluster, you can run the command:\n\n```\noc expose service/blog-django-py\n\
    ```\n\nSwitch to the OpenShift web console by selecting on _Console_ to verify\
    \ that the application has been deployed. Select on the URL shortcut icon displayed\
    \ for the application on the _Topology_ view for the project to visit the application.\n\
    \nAlternatively, to view the hostname assigned to the route created from the command\
    \ line, you can run the command:\n\n```\noc get route/blog-django-py\n```\n"
  difficulty: basic
  slug: 05-deploying-using-the-command-line
  tabs:
  - hostname: crc-nonest-1
    title: CLI
    type: terminal
  - hostname: crc-nonest-1
    port: 30443
    title: OpenShift Web Console
    type: service
  - hostname: crc-nonest-1
    path: /root
    title: Visual Editor
    type: code
  timelimit: 300
  title: Topic 5 - Deploying Using the Command Line
  type: challenge
description: "## Goal\n\nLearn how to deploy an application on OpenShift with the\
  \ web console and with the `oc` command line tool.\n\n## Concepts\n\n* Deploying\
  \ existing container images on an OpenShift cluster\n* OpenShift Web Console\u2019\
  s Topology view\n* OpenShift Projects and Applications\n* OpenShift `oc` tool\u2019\
  s `new-app` subcommand\n\n## Use case\n\nYou can deploy a container image on an\
  \ OpenShift cluster to make the application easier to manage, scale, connect and\
  \ monitor.\n\nThis OpenShift cluster will self-destruct in one hour.\n"
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: openshift
private: true
published: false
skipping_enabled: false
slug: using-the-cluster-deploying-images
tags:
- openshift
title: Deploying Applications From Images
type: track
