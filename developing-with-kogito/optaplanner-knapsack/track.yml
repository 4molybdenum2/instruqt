challenges:
- assignment: "In this step, we will create the OptaPlanner Quarkus application skeleton.\n\
    \n# The Project\n\nWe start with a basic Maven-based Quarkus application which\
    \ has been generated from the Quarkus Maven Plugin.\n\n# The Application You Will\
    \ Build\n\nIn this scenario, we will build an OptaPlanner application on Quarkus\
    \ that will solve the knapsack problem. The knapsack problem is a problem in which\
    \ we need to put ingots with a certain weight and a certain value into a knapsack\
    \ in such a way that we maximize the value without exceeding the maximum knapsack\
    \ weight. The knapsack problem is an _NP-complete_ problem, which means it's not\
    \ solvable in polynomial time. In other words, when the size of the problem grows,\
    \ the time needed to solve the problem grows exponentially. For even relatively\
    \ small problems, this means that finding the best solution can take billions\
    \ of years.\n\nOptaPlanner is an A.I. constraint satisfaction solver that enables\
    \ us to find the optimal solution to these kinds of problems in the limited time\
    \ at our disposal. In this scenario, we will build an OptaPlanner application\
    \ that runs on Quarkus to solve this problem.\n\n\n# Creating a basic project\n\
    \nThe easiest way to create a new Quarkus project is to click the following Maven\
    \ command:\n\n`mvn io.quarkus:quarkus-maven-plugin:1.7.0.Final:create \\\n   \
    \ -DprojectGroupId=com.redhat \\\n    -DprojectArtifactId=knapsack-optaplanner-quarkus\
    \ \\\n    -DclassName=\"com.redhat.knapsackoptaplanner.solver.KnapsackResource\"\
    \ \\\n    -Dpath=\"/knapsack\" \\\n    -Dextensions=\"org.optaplanner:optaplanner-quarkus,org.optaplanner:optaplanner-quarkus-jackson,quarkus-resteasy-jackson,quarkus-smallrye-openapi\"\
    `{{execute}}\n\n\nThis command uses the Quarkus Maven plugin and generates a basic\
    \ Quarkus application that includes the OptaPlanner extension in the `knapsack-optaplanner-quarkus`\
    \ subdirectory.\n\nClick the following command to remove the automatically generated\
    \ unit-test classes:\n```\nrm -rf /root/projects/kogito/knapsack-optaplanner-quarkus/src/test/java/com\n\
    ````\n\n# Running the Application\n\nClick the following command to change directory\
    \ to the `knapsack-optaplanner-quarkus` directory:\n\n```\ncd /root/projects/kogito/knapsack-optaplanner-quarkus\n\
    ```\n\nClick the next command to run the OptaPlanner application in Quarkus development\
    \ mode. This enables us to keep the application running while we implement our\
    \ application logic. OptaPlanner and Quarkus will hot reload the application (update\
    \ changes while the application is running) when it is accessed and changes have\
    \ been detected:\n\n```\nmvn clean compile quarkus:dev\n```\n\nThe application\
    \ starts in development mode, but returns an error that it can't find any classes\
    \ annotated with `@PlanningSolution`. This is expected! We will implement these\
    \ classes later.\n\n# Congratulations!\n\nWe've seen how to create the skeleton\
    \ of a basic OptaPlanner on Quarkus application, and start the application in\
    \ Quarkus development mode.\n\nIn the next step we'll add the domain model of\
    \ our application.\n"
  difficulty: basic
  slug: 01-create-project
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 1
  type: challenge
- assignment: "In the previous step we've created a skeleton OptaPlanner application\
    \ with Quarkus and started the application in Quarkus development mode. In this\
    \ step we'll create the domain model of our application.\n\n## PlanningEntities\
    \ and PlanningVariables\n\nEach OptaPlanner application has planning entities\
    \ (`@PlanningEntity` annotation) and planning variables (`@PlanningVariable` annotation).\
    \ Planning entities are the entities in our domain that OptaPlanner needs to plan.\
    \ In the knapsack problem, these are the ingots because these are the entities\
    \ that are either put into the knapsack or not.\n\nPlanning variables are properties\
    \ of a planning entity that specify a planning value that changes during planning.\
    \ In the knapsack problem, this is the property that tells OptaPlanner whether\
    \ or not the ingot is _selected_. That is, whether or not it is put in the knapsack.\
    \ Note that in this example we have a single knapsack. If we have multiple knapsacks,\
    \ the actual knapsack is the planning variable, because an ingot can be placed\
    \ in different knapsacks.\n\n## Ingot\n\nTo implement the `Ingot` class, first\
    \ we need to create a new package in our project:\n\n`mkdir -p /root/projects/kogito/knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain`{{execute\
    \ T2}}\n\nClick on the following line to open a new `Ingot.java` file in this\
    \ package: `knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Ingot.java`{{open}}\n\
    \nClick _Copy to Editor_ to copy the source code into the new `Ingot.java`file.\n\
    \n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Ingot.java\"\
    \ data-target=\"replace\">\npackage com.redhat.knapsackoptaplanner.domain;\n\n\
    import org.optaplanner.core.api.domain.entity.PlanningEntity;\nimport org.optaplanner.core.api.domain.variable.PlanningVariable;\n\
    \n/**\n * Ingot\n */\n//Add PlanningEntity annotation\npublic class Ingot {\n\n\
    \    private int weight;\n\n    private int value;\n\n    //Add Planning Variable\
    \ annotation\n    private Boolean selected;\n\n    public Ingot() {\n    }\n\n\
    \    public int getWeight() {\n        return weight;\n    }\n\n    public void\
    \ setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public\
    \ int getValue() {\n        return value;\n    }\n\n    public void setValue(int\
    \ value) {\n        this.value = value;\n    }\n\n    public Boolean getSelected()\
    \ {\n        return selected;\n    }\n\n    public void setSelected(Boolean selected)\
    \ {\n        this.selected = selected;\n    }\n\n}\n</pre>\n\n### Planning Entity\n\
    \nWe first need to tell OptaPlanner that this class is our `PlanningEntity` class.\
    \ To do this, click _Copy to Editor_ to set the `@PlanningEntity` annotation on\
    \ the class.\n\n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Ingot.java\"\
    \ data-target=\"insert\" data-marker=\"//Add PlanningEntity annotation\">\n@PlanningEntity\n\
    </pre>\n\n#### Planning Variable\n\nNext, we need to configure our planning variable.\
    \ In this example, the planning variable (the property that changes during planning)\
    \ is the `selected` attribute of the planning entity class. Mark this property\
    \ with the `@PlanningVariable` annotation and specify the _valuerange provider_.\
    \ This is the entity in our application that provides the range of possible values\
    \ of our planning variable.\n\n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Ingot.java\"\
    \ data-target=\"insert\" data-marker=\"  //Add Planning Variable annotation\"\
    >\n  @PlanningVariable(valueRangeProviderRefs = \"selected\")\n</pre>\n\nIn this\
    \ example, because our planning variable is a `Boolean` value, the _valuerange_\
    \ is simply `true` and `false`. We will define this provider in the next step.\n\
    \n## Knapsack\n\nIn our application, we need to have an object that defines the\
    \ maximum weight of our knapsack. So we will implement a simple `Knapsack` class\
    \ that has a `maxWeight` attribute that can hold this value.\n\nClick the following\
    \ line to open a new `Knapsack.java` file in this package: `knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Knapsack.java`{{open}}\n\
    \nClick _Copy to Editor_ to add a class with a single `maxWeight` attribute.\n\
    \n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/Knapsack.java\"\
    \ data-target=\"replace\">\npackage com.redhat.knapsackoptaplanner.domain;\n\n\
    public class Knapsack {\n\n    private int maxWeight;\n\n    public Knapsack()\
    \ {\n    }\n\n    public int getMaxWeight() {\n        return maxWeight;\n   \
    \ }\n\n    public void setMaxWeight(int maxWeight) {\n        this.maxWeight =\
    \ maxWeight;\n    }\n\n}\n</pre>\n\n## Congratulations!\n\nWe've implemented the\
    \ domain model of our OptaPlanner Quarkus application. In the next step, we will\
    \ implement the _PlanningSolution_ of our application.\n"
  difficulty: basic
  slug: 02-implement-domain-model
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 2
  type: challenge
- assignment: "In the previous step we've implemented the domain model of the application.\
    \ Now it's time to implement the planning solution.\n\n## PlanningSolution\n\n\
    The planning solution of our OptaPlanner application represents both the problem\
    \ (i.e. the uninitialized solution), the working solution, and the best solution\
    \ which is the solution returned by OptaPlanner when solving is ended.\n\nThe\
    \ `PlanningSolution` class therefore contains:\n\n* The collection of planning\
    \ entities that need to be planned. In this case, this is a list of `Ingots`.\n\
    * Zero or more collections/ranges of planning variables. In this simple example\
    \ we only have a range of boolean values (i.e. `true` and `false`) that indicate\
    \ whether an ingot has been selected or not.\n* Possible problem fact properties.\
    \ These are properties that are neither a planning entity nor a planning variable,\
    \ but are required by the constraints during solving. In this example the `Knapsack`\
    \ is such a property because the problem requires the maximum weight of the knapsack\
    \ in the constraint evaluation.\n* The `Score` of the solution. This contains\
    \ the score calculated by the OptaPlanner `ScoreCalculator` based on the hard\
    \ and soft constraints.\n\n## KnapsackSolution\n\nWe will now implement the skeleton\
    \ of our `KnapsackSolution` class. To do this, click the following line to create\
    \ a new `KnapsackSolution.java` file: `knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java`{{open}}\n\
    \nClick _Copy to Editor_ to copy the source code into the new `KnapsackSolution.java`\
    \ file.\n\n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"replace\">\npackage com.redhat.knapsackoptaplanner.domain;\n\n\
    import java.util.List;\n\nimport org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n\
    import org.optaplanner.core.api.domain.solution.PlanningScore;\nimport org.optaplanner.core.api.domain.solution.PlanningSolution;\n\
    import org.optaplanner.core.api.domain.solution.drools.ProblemFactProperty;\n\
    import org.optaplanner.core.api.domain.valuerange.CountableValueRange;\nimport\
    \ org.optaplanner.core.api.domain.valuerange.ValueRangeFactory;\nimport org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n\
    import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n\n//Add\
    \ PlanningSolution annotation here\npublic class KnapsackSolution {\n\n//Add Ingots\
    \ here\n\n//Add Knapsack here\n\n//Add selected valuerangeprovider here\n\n//Add\
    \ PlanningScore here\n\n  public KnapsackSolution() {\n  }\n\n//Add getters and\
    \ setters here\n}\n</pre>\n\nTo mark this class as our `PlanningSolution` class,\
    \ we need to add the `@PlanningSolution` annotation:\n\n<pre class=\"file\" data-filename=\"\
    ./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add PlanningSolution annotation here\"\
    >\n@PlanningSolution\n</pre>\n\n\n### Planning Entities\n\nWe can now add the\
    \ collection of planning entities to our class. As stated earlier, in this implementation\
    \ this is a list of ingots. We also need to tell OptaPlanner that this is the\
    \ collection of planning entities, and therefore need to annotate this field with\
    \ the `@PlanningEntityCollectionProperty` annotation.\n\n<pre class=\"file\" data-filename=\"\
    ./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add Ingots here\">\n  @PlanningEntityCollectionProperty\n\
    \  private List&lt;Ingot&gt; ingots;\n</pre>\n\n### Valuerange Provider\n\nNext,\
    \ we can add the _valuerange provider_ to our solution class. This is the provider\
    \ of the valuerange of our `selected` planning variable that we've defined in\
    \ our `Ingot` planning entity class. Because this planning variable is a boolean\
    \ value, we need to create a `Boolean` value range.\n\n<pre class=\"file\" data-filename=\"\
    ./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add selected valuerangeprovider here\"\
    >\n  @ValueRangeProvider(id = \"selected\")\n  public CountableValueRange<Boolean>\
    \ getSelected() {\n    return ValueRangeFactory.createBooleanValueRange();\n \
    \ }\n</pre>\n\n### Problem Facts\n\nThe constraints that we will implement in\
    \ the following step of our scenario need to know the maximum weight of our knapsack\
    \ to be able to determine whether the knapsack can carry the total weight of the\
    \ selected ingots. For this reason, our constraints need to have access to the\
    \ `Knapsack` instance. We will therefore click _Copy to Editor_ to create a knapsack\
    \ attribute in our planning solution and annotate it with the `@ProblemFactProperty`\
    \ annotation (note that there is also an `@ProblemFactCollectionProperty` annotation\
    \ for collections).\n\n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add Knapsack here\">\n  @ProblemFactProperty\n\
    \  private Knapsack knapsack;\n</pre>\n\n### Planning Score\n\nThe next thing\
    \ we need to add is the `PlanningScore`. In this knapsack problem we have two\
    \ score types: a _hard score_ and a _soft score_. In OptaPlanner, a broken hard\
    \ score defines an _infeasible solution_. In our knapsack application, for example,\
    \ this is the case when the total weight of the selected ingots is higher than\
    \ the maximum weight of the knapsack. The soft score is the score that we want\
    \ to optimize. In this example, this is the total value of the selected ingots,\
    \ because we want to have a solution with the highest possible values.\n\nClick\
    \ _Copy to Editor_ to add a `HardSoftScore` attribute to the planningsolution\
    \ class and add an `@PlanningScore` annotation to this attribute.\n\n<pre class=\"\
    file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add PlanningScore here\">\n  @PlanningScore\n\
    \  private HardSoftScore score;\n</pre>\n\n### Getters and Setters\n\nFinally,\
    \ we also need to create the _getters and setters_ for our attributes.\n\n<pre\
    \ class=\"file\" data-filename=\"/knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/domain/KnapsackSolution.java\"\
    \ data-target=\"insert\" data-marker=\"//Add getters and setters here\">\n  public\
    \ List&lt;Ingot&gt; getIngots() {\n      return ingots;\n  }\n\n  public void\
    \ setIngots(List&lt;Ingot&gt; ingots) {\n      this.ingots = ingots;\n  }\n\n\
    \  public Knapsack getKnapsack() {\n      return knapsack;\n  }\n\n  public void\
    \ setKnapsack(Knapsack knapsack) {\n      this.knapsack = knapsack;\n  }\n\n \
    \ public HardSoftScore getScore() {\n      return score;\n  }\n\n  public void\
    \ setScore(HardSoftScore score) {\n      this.score = score;\n  }\n</pre>\n\n\
    That's it. We're now ready to define our constraints.\n\n## Congratulations!\n\
    \nIn this step you've implemented the `PlanningSolution` of your application.\
    \ Well done! In the next step we will implement the constraints of our problem\
    \ using `ConstraintStreams`.\n"
  difficulty: basic
  slug: 03-implement-planning-solution
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 3
  type: challenge
- assignment: "In the previous step you've implemented the `PlanningSolution` of our\
    \ application. We can now implement constraint rules.\n\n## Constraints\n\nConstraints\
    \ define how the score of a solution is calculated. Based on the current assignment\
    \ of planning variables to planning entities, we can calculate a score for the\
    \ solution using constraints. This example, as stated earlier, uses a _hard_ and\
    \ _soft_ score. A _hard_ score defines an infeasible solution and the _soft_ score\
    \ is the score that we want to optimize. Our constraints will calculate these\
    \ scores.\n\nIn this example we will implement two constraints. The first constraint\
    \ states that a hard constraint is broken when the total weight of the selected\
    \ ingots is greater than the maximum weight of the knapsack. That is, if we select\
    \ ingots that have a total weight that is greater than the maximum weight of our\
    \ knapsack, the solution is infeasible.\n\nThe soft constraint, the score that\
    \ we want to optimize, is the total value of the ingots. That is, we want to find\
    \ the solution that maximizes our total value. For this we will implement a constraint\
    \ that calculates this as a soft score.\n\n## ConstraintStreams\n\nOptaPlanner\
    \ provides various options to implement our constraints:\n\n* **Easy Java**: Java\
    \ implementation that recalculates the full score for every move. Easy to write\
    \ but extremely slow. Do not use this in production!\n* **Incremental Java**:\
    \ Java implementation that does incremental score calculation on every move. Fast,\
    \ but very hard to write and maintain. Not recommended!\n* **Drools**: Rule-based\
    \ constraints written in DRL. Incremental and fast calculation of constraints.\
    \ Requires knowledge of Drools.\n* **Constraint Streams**: Constraints written\
    \ in an API inspired by Java Streams. Incremental and fast calculation of constraints.\
    \ Requires knowledge of the Streams API.\n\nIn this example we will use the Constraint\
    \ Streams API.\n\nWe will start by implementing the `ConstraintProvider`. The\
    \ implementation class is automatically picked up by the OptaPlanner Quarkus runtime\
    \ without the need for any configuration.\n\nWe will implement the `KnapsackConstraintProvider`\
    \ class. To do this, click the following command to create a new package in our\
    \ project:\n\n`mkdir -p /root/projects/kogito/knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver`{{execute\
    \ T2}}\n\nNow click the following path to open a new `KnapsackConstraintProvider.java`\
    \ file in this package: `knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackConstraintProvider.java`{{open}}\n\
    \nClick _Copy to Editor_ to copy the source code into the new `KnapsackConstraintProvider.java`file.\n\
    \n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackConstraintProvider.java\"\
    \ data-target=\"replace\">\npackage com.redhat.knapsackoptaplanner.solver;\n\n\
    import com.redhat.knapsackoptaplanner.domain.Ingot;\nimport com.redhat.knapsackoptaplanner.domain.Knapsack;\n\
    \nimport org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\nimport\
    \ org.optaplanner.core.api.score.stream.Constraint;\nimport org.optaplanner.core.api.score.stream.ConstraintCollectors;\n\
    import org.optaplanner.core.api.score.stream.ConstraintFactory;\nimport org.optaplanner.core.api.score.stream.ConstraintProvider;\n\
    \npublic class KnapsackConstraintProvider implements ConstraintProvider {\n\n\
    \    @Override\n    public Constraint[] defineConstraints(ConstraintFactory constraintFactory)\
    \ {\n        return new Constraint[] {\n            maxWeight(constraintFactory),\n\
    \            maxValue(constraintFactory)\n        };\n    }\n\n    /*\n     *\
    \ Hard constraint\n     */\n//Add hard constraint here\n\n\n    /*\n     * Soft\
    \ constraint\n     */\n//Add soft constraint here\n\n\n}\n</pre>\n\nClick _Copy\
    \ to Editor_. The hard constraint sums up the weight of all selected ingots and\
    \ compares this with the maximum weight of the knapsack.\n\n<pre class=\"file\"\
    \ data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackConstraintProvider.java\"\
    \ data-target=\"insert\" data-marker=\"//Add hard constraint here\">\n  private\
    \ Constraint maxWeight(ConstraintFactory constraintFactory) {\n    return constraintFactory.from(Ingot.class).filter(i\
    \ -> i.getSelected())\n            .groupBy(ConstraintCollectors.sum(i -> i.getWeight())).join(Knapsack.class)\n\
    \            .filter((ws, k) -> ws > k.getMaxWeight())\n            .penalize(\"\
    Max Weight\", HardSoftScore.ONE_HARD, (ws, k) -> ws - k.getMaxWeight());\n  }\n\
    </pre>\n\nClick _Copy to Editor_. The soft constraints sums up all the values\
    \ of the selected ingots.\n\n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackConstraintProvider.java\"\
    \ data-target=\"insert\" data-marker=\"//Add soft constraint here\">\n  private\
    \ Constraint maxValue(ConstraintFactory constraintFactory) {\n    return constraintFactory.from(Ingot.class)\n\
    \            .filter(Ingot::getSelected)\n            .reward(\"Max Value\", HardSoftScore.ONE_SOFT,\
    \ Ingot::getValue);\n  }\n</pre>\n\n## Congratulations!\n\nIn this step we've\
    \ implemented our first OptaPlanner constraints using the `ConstraintStreams`\
    \ API. In the next step we will implement our RESTful resource and test our application.\n"
  difficulty: basic
  slug: 04-constraints
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 4
  type: challenge
- assignment: "In the previous step we've implemented the constraints of the application\
    \ using the `ConstraintStreams` API. We will now create the RESTful resource of\
    \ our application and take the application for a test-drive.\n\n# KnapsackResource\n\
    \nWhen we created the initial OptaPlanner Quarkus application using the Quarkus\
    \ Maven plugin, we defined the resource class of our RESTful endpoint (being `KnapsackResource`).\n\
    \nWe will now implement the skeleton of our `KnapsackSolution` class. To do this,\
    \ we first have to open the `KnapsackResource.java` file by clicking the following\
    \ path: `knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackResource.java`{{open}}\n\
    \nThe `KnapsackResource` class is implemented as a Quarkus JAX-RS service. Click\
    \ _Copy to Editor_ to inject an OptaPlanner `SolverManager` instance to manage\
    \ the `Solver` instances that will solve our problem.\n\n<pre class=\"file\" data-filename=\"\
    ./knapsack-optaplanner-quarkus/src/main/java/com/redhat/knapsackoptaplanner/solver/KnapsackResource.java\"\
    \ data-target=\"replace\">\npackage com.redhat.knapsackoptaplanner.solver;\n\n\
    import java.util.UUID;\nimport java.util.concurrent.ExecutionException;\n\nimport\
    \ javax.inject.Inject;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.POST;\n\
    import javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\
    \nimport com.redhat.knapsackoptaplanner.domain.KnapsackSolution;\n\nimport org.optaplanner.core.api.solver.SolverJob;\n\
    import org.optaplanner.core.api.solver.SolverManager;\n\n\n@Path(\"/knapsack\"\
    )\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n\
    public class KnapsackResource {\n\n    @Inject\n    private SolverManager&lt;KnapsackSolution,\
    \ UUID&gt; solverManager;\n\n    @POST\n    @Path(\"/solve\")\n    public KnapsackSolution\
    \ solve(KnapsackSolution problem) {\n        UUID problemId = UUID.randomUUID();\n\
    \        // Submit the problem to start solving\n        SolverJob&lt;KnapsackSolution,\
    \ UUID&gt; solverJob = solverManager.solve(problemId, problem);\n        KnapsackSolution\
    \ solution;\n        try {\n            // Wait until the solving ends\n     \
    \       solution = solverJob.getFinalBestSolution();\n        } catch (InterruptedException\
    \ | ExecutionException e) {\n            throw new IllegalStateException(\"Solving\
    \ failed.\", e);\n        }\n        return solution;\n    }\n}\n</pre>\n\nSolverManager\
    \ accepts (uninitialized) PlanningSolutions the problem), and passes this problem\
    \ to a managed Solver that runs on a separate thread to solve it. The SolverJob\
    \ runs until solving ends, after which we can retrieve the final best solution.\n\
    \n# Configuring the Solver\n\nOptaPlanner will keep solving the problem indefinitely\
    \ if we don't configure a _termination strategy_. A _termnination strategy_ tells\
    \ OptaPlanner when to stop solving, for example based on the number of seconds\
    \ spent, or if a score has not improved in a specified amount of time.\n\nIn an\
    \ OptaPlanner Quarkus application, we can set this _termination strategy_ by simply\
    \ adding a configuration property in the Quarkus `application.properties` configuration\
    \ file. Let's first open this file by clicking the following path: `knapsack-optaplanner-quarkus/src/main/resources/application.properties`{{open}}\n\
    \nClick _Copy to Editor_ to add our _termination strategy_ configuration property:\n\
    \n<pre class=\"file\" data-filename=\"./knapsack-optaplanner-quarkus/src/main/resources/application.properties\"\
    \ data-target=\"replace\">\n# Configuration file\n# key = value\nquarkus.optaplanner.solver.termination.spent-limit=10s\n\
    </pre>\n\nThe `quarkus.optaplanner.solver.termination.spent-limit` property is\
    \ set to 10 seconds, which means that the solver will stop solving after 10 seconds\
    \ and return the best result found so far.\n\n## Running the Application\nBecause\
    \ we still have our application running in Quarkus development mode, we can simply\
    \ access the Swagger-UI of our application by clicking [here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/swagger-ui).\
    \ Hitting this endpoint will force the OptaPlanner Quarkus application to do a\
    \ hot-reload and recompile and deploy the changes we made in our application \"\
    on-the-fly\".\n\nYou will see our `/knapsack/solve` RESTful API listed. We can\
    \ now fire a RESTful request with a knapsack problem to this endpoint. We will\
    \ do this from the terminal using cURL. Note that it will take 10 seconds for\
    \ the response to return because we've set the OptaPlanner termination strategy\
    \ to 10 seconds:\n\n`curl --location --request POST 'http://localhost:8080/knapsack/solve'\
    \ \\\n--header 'Accept: application/json' \\\n--header 'Content-Type: application/json'\
    \ \\\n--data-raw '{\n\t\"knapsack\": {\n\t\t\"maxWeight\": 10\n\t},\n\t\"ingots\"\
    \ : [\n\t\t{\n\t\t\t\"weight\": 4,\n\t\t\t\"value\": 15\n\t\t},\n\t\t{\n\t\t\t\
    \"weight\": 4,\n\t\t\t\"value\": 15\n\t\t},\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\
    \t\"value\": 12\n\t\t},\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\t\"value\": 12\n\t\t\
    },\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\t\"value\": 12\n\t\t},\n\t\t{\n\t\t\t\"\
    weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\": 2,\n\t\t\t\"\
    value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\
    \t{\n\t\t\t\"weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\"\
    : 2,\n\t\t\t\"value\": 7\n\t\t}\n\t]\n}'`{{execute T2}}\n\nThe response shows\
    \ which ingots have been selected. These ingots will have their `selected` attribute\
    \ set to `true`.\n\n## Congratulations!\nYou've implemented the RESTful endpoint\
    \ of the application, hot-reloaded the app using the Quarkus dev-mode and solved\
    \ a knapsack problem. Well done! In the next step we will deploy this application\
    \ to OpenShift to run our OptaPlanner solution as a true cloud-native application.\n"
  difficulty: basic
  slug: 05-implement-rest-application
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 5
  type: challenge
- assignment: "In the previous step we've implemented the RESTful resource of our\
    \ OptaPlanner Quarkus application and solved a knapsack problem. In this step\
    \ of the scenario, we will deploy our service to OpenShift and scale it up to\
    \ be able to handle production load.\n\nBefore getting started with this step,\
    \ stop the running application in terminal 1 using `CTRL-C`.\n\n## Login to OpenShift\n\
    \nClick the following command.\n\n`oc login --server=https://[[HOST_SUBDOMAIN]]-6443-[[KATACODA_HOST]].environments.katacoda.com\
    \ --insecure-skip-tls-verify=true`{{execute T1}}\n\nEnter our test username and\
    \ password:\n* Username: **developer**\n* Password: **developer**\n\n## Create\
    \ a new project\n\nClick the following command.\n\n`oc new-project knapsack-optaplanner\
    \ --display-name=\"Knapsack OptaPlanner Solver\"`{{execute T1}}\n\n## Open the\
    \ OpenShift Web Console**\n\nOpenShift ships with a web-based console that will\
    \ allow users to perform various tasks via a browser. To get a feel for how the\
    \ web console works, click the \"OpenShift Console\" tab next to the \"Local Web\
    \ Browser\" tab.\n\n![OpenShift Console Tab](/openshift/assets/middleware/quarkus/openshift-console-tab.png)\n\
    \n> Note that we get a security certificate error due to the use of self-signed\
    \ security certificates. Accept the exception in the browser to continue to the\
    \ OpenShift console.\n\nThe first screen we see is the authentication screen.\
    \ Enter the username (developer) and password (developer) and click _Log In_.\n\
    \n![Web Console Login](/openshift/assets/middleware/middleware-kogito/login.png)\n\
    \nAfter we authenticate to the web console, we see a list of projects that we\
    \ have permission to work with.\n\n![Web Console Projects](/openshift/assets/middleware/middleware-kogito/openshift-knapsack-optaplanner-project.png)\n\
    \nClick on `knapsack-optaplanner` to go to the project overview page which lists\
    \ all of the routes, services, deployments, and pods that are running as part\
    \ of this project:\n\n![Web Console Overview](/openshift/assets/middleware/middleware-kogito/openshift-knapsack-optaplanner-overview.png)\n\
    \nThere's nothing there now, but that's about to change.\n\n## Deploy to OpenShift\n\
    \nFirst, we need to compile and package our application. Click this command to\
    \ compile our application as an OptaPlanner Quarkus image to run in JVM mode.\n\
    \n`mvn clean package`{{execute T1}}\n\nNote that our application also supports\
    \ being compiled into a native image using GraalVM.\n\nNext, click this command\
    \ to create a new _binary_ build within OpenShift.\n\n`oc new-build registry.access.redhat.com/openjdk/openjdk-11-rhel7:latest\
    \ --binary --name=knapsack-optaplanner -l app=knapsack-optaplanner`{{execute T1}}\n\
    \nOur build needs both the _runner_ JAR file as well as the _lib_ directory. Click\
    \ this command to create a temporary directory in which we will copy those assets,\
    \ and use that directory to upload to our S2I image.\n\n`rm -rf /tmp/knapsack-optaplanner-build\
    \ && mkdir -p /tmp/knapsack-optaplanner-build && cp target/knapsack-optaplanner-quarkus-1.0-SNAPSHOT-runner.jar\
    \ /tmp/knapsack-optaplanner-build/knapsack-optaplanner-quarkus-1.0-SNAPSHOT-runner.jar\
    \ && cp -R target/lib /tmp/knapsack-optaplanner-build/lib`{{execute T1}}\n\n\n\
    And then click this command to start the build, which will take about a minute\
    \ or two to complete.\n\n`oc start-build knapsack-optaplanner --from-dir=/tmp/knapsack-optaplanner-build\
    \ --follow`{{execute T1}}\n\nAfter that's done, click here to deploy it as an\
    \ OpenShift application:\n\n`oc new-app knapsack-optaplanner`{{execute T1}}\n\n\
    And click here to expose it to the world:\n\n`oc expose service knapsack-optaplanner`{{execute\
    \ T1}}\n\nFinally, click here to make sure it's actually finished rolling out:\n\
    \n`oc rollout status -w dc/knapsack-optaplanner`{{execute T1}}\n\nWait for that\
    \ command to report `replication controller \"knapsack-optaplanner-1\" successfully\
    \ rolled out` before continuing.\n\nAnd now we can access our application using\
    \ `cURL` once again. Click the following command. Note that we again need to wait\
    \ 10 seconds for the response to return:\n\n`curl --location --request POST 'http://knapsack-optaplanner-knapsack-optaplanner.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/knapsack/solve'\
    \ \\\n--header 'Accept: application/json' \\\n--header 'Content-Type: application/json'\
    \ \\\n--data-raw '{\n\t\"knapsack\": {\n\t\t\"maxWeight\": 10\n\t},\n\t\"ingots\"\
    \ : [\n\t\t{\n\t\t\t\"weight\": 4,\n\t\t\t\"value\": 15\n\t\t},\n\t\t{\n\t\t\t\
    \"weight\": 4,\n\t\t\t\"value\": 15\n\t\t},\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\
    \t\"value\": 12\n\t\t},\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\t\"value\": 12\n\t\t\
    },\n\t\t{\n\t\t\t\"weight\": 3,\n\t\t\t\"value\": 12\n\t\t},\n\t\t{\n\t\t\t\"\
    weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\": 2,\n\t\t\t\"\
    value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\
    \t{\n\t\t\t\"weight\": 2,\n\t\t\t\"value\": 7\n\t\t},\n\t\t{\n\t\t\t\"weight\"\
    : 2,\n\t\t\t\"value\": 7\n\t\t}\n\t]\n}'`{{execute T1}}\n\n\nSo now our app is\
    \ deployed to OpenShift. We can also see it in the [Overview in the OpenShift\
    \ Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/knapsack-optaplanner/deploymentconfigs/knapsack-optaplanner)\
    \ with its single replica running in 1 pod (the blue circle).\n\n## Scale the\
    \ application\n\nIn order to be able to handle production load and have high availability\
    \ semantics, we need to scale the application and add a number of extra running\
    \ pods.\n\nClick this command to scale the number of PODs via the OpenShift _oc_\
    \ client:\n\n`oc scale --replicas=10 dc/knapsack-optaplanner`{{execute T1}}\n\n\
    Back in the [Overview in the OpenShift Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/k8s/ns/knapsack-optaplanner/deploymentconfigs/knapsack-optaplanner)\
    \ we can see the app scaling dynamically up to 10 pods.\n\nThis should only take\
    \ a few seconds to complete the scaling. The application is now ready to take\
    \ production load.\n\n## Congratulations!\n\nIn this scenario we got a glimpse\
    \ of the power of OptaPlanner apps on a Quarkus runtime on OpenShift. We've packaged\
    \ our Knapsack OptaPlanner solver in a container image, deployed it on OpenShift,\
    \ and solved a knapsack problem. Finally, we've scaled the environment to 10 pods\
    \ to be able to serve production load. Well done!\n"
  difficulty: basic
  slug: 06-deploy-on-openshift
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 6
  type: challenge
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner:
- openshift
private: 'false'
published: 'true'
skipping_enabled: 'true'
slug: optaplanner-knapsack
tags:
- openshift
title: OptaPlanner and Quarkus
type: truck
