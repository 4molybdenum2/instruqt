challenges:
- assignment: 'In order to run Camel K, you will need access to an Kubernetes/OpenShift
    environment. Let''s setup the fundamentals.


    ## Logging in to the Cluster via Dashboard


    Click the [Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com)
    tab to open the dashboard.


    You will then able able to login with admin permissions with:


    * **Username:** ``admin``

    * **Password:** ``admin``


    ## Installing Camel K from the OpenShift OperatorHub

    Camel K Operator can be deployed on the OpenShift cluster from the OperatorHub.
    The OperatorHub is available from the OpenShift Container Platform web console
    and provides an interface for cluster administrators to discover and install Operators.


    It is responsible for building, deploying Camel Applications and also creating
    surrounding resources. It is also responsible for watching any code or configuration
    updates and automatically updates it. To install simply run the command.


    In the left navigation menu, click *Catalog* > *OperatorHub*

    In the Filter by keyword text box, enter Camel K to find the *Camel K Operator*.

    Read the information about the Operator, and click *Install*. This displays the
    Create Operator Subscription page.


    ![operatorhub](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step1-01-operatorhub.png)


    Select the following subscription settings:

    - Update Channel > *Stable*

    - Installation Mode > *All namespaces on the cluster (default)*

    - Approval Strategy > Automatic


    ![installoperator](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step1-02-installoperator.png)


    Click Subscribe. This displays the Operators > Installed Operators page.


    Wait a few moments until the Status for the Camel K Operator displays Succeeded
    and the subscription is Up to Date.


    ![installed](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step1-03-installed.png)


    ## Logging in to the Cluster via CLI


    Before creating any applications, login as admin. This will be required if you
    want to log in to the web console and

    use it.


    To login to the OpenShift cluster from the _Terminal_ run:


    ```

    oc login -u admin -p admin`

    ```


    This will log you in using the credentials:


    * **Username:** ``admin``

    * **Password:** ``admin``


    Use the same credentials to log into the web console.


    ## Setup Knative Eventing



    OpenShift Serverless Eventing is designed to address a common need for cloud native
    development and provides composable primitives to enable late-binding event sources
    and event consumers. OpenShift Serverless Operator is subscribed in the cluster
    already.Let''s go ahead and setup Knative Eventing to set the ground for the event
    mesh.


    Creating the knative-eventing namespace:


    ```

    oc new-project knative-eventing`

    ```



    Let''s go ahead setup KnativeEventing in the namespace


    ```

    oc apply -f serverless/eventing.yaml -n knative-eventing`

    ```


    Once Knative Eventing complete it''s setup. You will see all the pod in *Running
    status*, it means it is successfully installed.


    ```

    oc get pod -w`

    ```


    ```

    NAME                                    READY   STATUS      RESTARTS   AGE

    broker-controller-6b4659f8cc-nz7hl      1/1     Running     0          89s

    broker-filter-659f5549b8-4gcwm          1/1     Running     0          88s

    broker-ingress-86c4b766dc-bwn4r         1/1     Running     0          87s

    eventing-controller-7d654894f4-mgdvp    1/1     Running     0          97s

    eventing-webhook-658fb449b6-hsv66       1/1     Running     0          97s

    imc-controller-6bf889454d-k79lf         1/1     Running     0          81s

    imc-dispatcher-7dbddfbd5f-9ltlh         1/1     Running     0          81s

    mt-broker-controller-5b9986bd46-6svnk   1/1     Running     0          86s

    ```


    Ctrl+C to exit the command.

    '
  difficulty: basic
  slug: step1
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 1
  type: challenge
- assignment: "## Auto Bitcoin Trading System\n\nThe example shows a simplified trading\
    \ application that analyzes price variations of Bitcoins (BTC / USDT), and automate\
    \ trading base on the predicted returns. In order to keep the system flexible\
    \ with pluggable prediction logics, we are going to break the system into three\
    \ separate parts.\n- *Source* - Load realtime Bitcoins values.\n- *Predictors*\
    \ - Pluggable predictors with various strategy.  \n- *Seller Alert* - Seller alert\
    \ (Mainly to display the result).\n\nAssume the market only open for couple of\
    \ hours, serverless application can optimize resource usage.\nIn between these\
    \ separate serverless services, events are pass through an *event mesh*.\n\n![overview](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step2-00-overview.png)\n\
    \n\n#### Enabling the Knative Eventing Broker\n\nThe central piece of the event\
    \ mesh that we're going to create is the Knative Eventing broker. It is a publish/subscribe\
    \ entity that Camel K integrations will use to publish events or subscribe to\
    \ it in order to being triggered when events of specific types are available.\
    \ Subscribers of the eventing broker are Knative serving services, that can scale\
    \ down to zero when no events are available for them.\n\n\n\nCreate a new OpenShift\
    \ project ``camel-knative``:\n```\noc new-project camel-knative`\n```\n\n\nTo\
    \ enable the eventing broker, we create a default broker in the current namespace\
    \ using namespace labeling:\n```\noc label namespace camel-knative knative-eventing-injection=enabled`\n\
    ```\n\nLet go ahead create predictors for market and load the market events\n\n\
    #### Run a prediction algorithms\n\nThe market data feed available in the mesh\
    \ can be now used to create different prediction algorithms that can publish events\
    \ when they believe it's the right time to sell or buy bitcoins, depending on\
    \ the trend of the exchange.\n\nWe're going to run the same (basic) algorithm\
    \ with different parameters, obtaining two predictors. The algorithm is basic\
    \ and it's just computing if the BTC variation respect to the last observed value\
    \ is higher than a threshold (expressed in percentage). The algorithm is bound\
    \ to the event mesh via the Predictor.java integration file.\n\nIn real life,\
    \ algorithms can be also much more complicated. For example, Camel K can be used\
    \ to bridge an external machine learning as-a-service system that will compute\
    \ much more accurate predictions. Algorithms can also be developed with other\
    \ ad hoc tools and plugged directly inside the Knative mesh using the Knative\
    \ APIs.\n\n\n#### Create the first prediction algorithms\n\nGo to the text editor\
    \ on the right, under the folder /root/camel-eventing. Right click on the directory\
    \ and choose New -> File and name it `Predictor.java`.\nPaste the following code\
    \ into the application.\n\n<pre class=\"file\" data-filename=\"Predictor.java\"\
    \ data-target=\"replace\">\n\n// camel-k: language=java\nimport org.apache.camel.builder.RouteBuilder;\n\
    \nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.camel.BindToRegistry;\n\
    import org.apache.camel.PropertyInject;\nimport org.apache.camel.builder.RouteBuilder;\n\
    \npublic class Predictor extends RouteBuilder {\n\n  @Override\n  public void\
    \ configure() throws Exception {\n\n      from(\"knative:event/market.btc.usdt\"\
    )\n        .unmarshal().json()\n        .transform().simple(\"${body[last]}\"\
    )\n        .log(\"Latest value for BTC/USDT is: ${body}\")\n        .to(\"seda:evaluate?waitForTaskToComplete=Never\"\
    )\n        .setBody().constant(\"\");\n\n      from(\"seda:evaluate\")\n     \
    \   .bean(\"algorithm\")\n        .choice()\n          .when(body().isNotNull())\n\
    \            .log(\"Predicted action: ${body}\")\n            .to(\"direct:publish\"\
    );\n\n      from(\"direct:publish\")\n        .marshal().json()\n        .removeHeaders(\"\
    *\")\n        .setHeader(\"CE-Type\", constant(\"predictor.{{predictor.name}}\"\
    ))\n        .to(\"knative:event\");\n\n  }\n  \n  @BindToRegistry(\"algorithm\"\
    )\n  public static class SimpleAlgorithm {\n\n    @PropertyInject(value=\"algorithm.sensitivity\"\
    , defaultValue = \"0.0001\")\n    private double sensitivity;\n\n    private Double\
    \ previous;\n    \n    public Map<String, Object> predict(double value) {\n  \
    \    Double reference = previous;\n      this.previous = value;\n\n      if (reference\
    \ != null && value < reference * (1 - sensitivity)) {\n        Map<String, Object>\
    \ res = new HashMap<>();\n        res.put(\"value\", value);\n        res.put(\"\
    operation\", \"buy\");\n        return res;\n      } else if (reference != null\
    \ && value > reference * (1 + sensitivity)) {\n        Map<String, Object> res\
    \ = new HashMap<>();\n        res.put(\"value\", value);\n        res.put(\"operation\"\
    , \"sell\");\n        return res;\n      }\n      return null;\n    }\n  }\n}\n\
    \n</pre>\n\nRun the following command to start the first predictor:\n\n```\nkamel\
    \ run --name simple-predictor -p predictor.name=simple camel-eventing/Predictor.java\
    \ -t knative-service.max-scale=1 --logs`\n```\n\nThe command above will deploy\
    \ the integration and wait for it to run, then it will show the logs in the console.\n\
    \nYou will see the following log if everything is working correctly.\n```\n[1]\
    \ 2020-10-02 00:09:32.499 INFO  [main] JacksonDataFormat - The option autoDiscoverObjectMapper\
    \ is set to false, Camel won't search in the registry\n[1] 2020-10-02 00:09:32.509\
    \ INFO  [main] JacksonDataFormat - The option autoDiscoverObjectMapper is set\
    \ to false, Camel won't search in the registry\n[1] 2020-10-02 00:09:32.811 INFO\
    \  [vert.x-eventloop-thread-0] VertxPlatformHttpServer - Vert.x HttpServerstarted\
    \ on 0.0.0.0:8080\n[1] 2020-10-02 00:09:32.817 INFO  [main] InternalRouteStartupManager\
    \ - Route: route1 started and consuming from: knative://event/market.btc.usdt\n\
    [1] 2020-10-02 00:09:32.819 INFO  [main] InternalRouteStartupManager - Route:\
    \ route2 started and consuming from: seda://evaluate\n[1] 2020-10-02 00:09:32.820\
    \ INFO  [main] InternalRouteStartupManager - Route: route3 started and consuming\
    \ from: direct://publish\n[1] 2020-10-02 00:09:32.821 INFO  [main] AbstractCamelContext\
    \ - Total 3 routes, of which 3 are started\n[1] 2020-10-02 00:09:32.821 INFO \
    \ [main] AbstractCamelContext - Apache Camel 3.4.0 (camel-k) started in 0.343\
    \ seconds\nCondition \"Ready\" is \"True\" for Integration simple-predictor\n\
    ```\nTo exit the log view, just click here or hit ctrl+c on the terminal window.\
    \ The integration will keep running on the cluster.\n\n\n\n#### Create the second\
    \ prediction algorithms\n\nThe second predictor with more sensitivity called better-predictor,\
    \ in the command line run:\n\n```\nkamel run --name better-predictor -p predictor.name=better\
    \ -p algorithm.sensitivity=0.0005 camel-eventing/Predictor.java -t knative-service.max-scale=1`\n\
    ```\n\nYou will be prompted with the following result, but please give a couple\
    \ of minutes for the route to be deployed.\n``integration \"better-predictor\"\
    \ created``\n\nYou can view both predictors from the [Developer Console Topology](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/camel-knative/graph).\n\
    (If Katacoda is slow, you might need to refresh the page to see the correct result.)\n\
    \n![predictors](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step2-01-predictors.png)\n\
    \nIt will be running first and shutdown since there are no activities yet.\n"
  difficulty: basic
  slug: step2
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 2
  type: challenge
- assignment: "#### Run a subscriber investor service\n\nWe are going to deploy a\
    \ service that will listen to the events from the simple predictor.And Display\
    \ the result from in log.\n\nGo to the text editor on the right, under the folder\
    \ /root/camel-eventing. Right click on the directory and choose New -> File and\
    \ name it `Investor.java`.\n\n\n<pre class=\"file\" data-filename=\"Investor.java\
    \ \" data-target=\"replace\">\n// camel-k: language=java\n\nimport org.apache.camel.builder.RouteBuilder;\n\
    \npublic class Investor extends RouteBuilder {\n  @Override\n  public void configure()\
    \ throws Exception {\n\n    from(\"knative:event/predictor.simple\")\n      .unmarshal().json()\n\
    \      .log(\"Let's ${body[operation]} at price ${body[value]} immediately!!\"\
    )\n      .setBody().constant(\"\");\n\n  }\n}\n</pre>\n\nTo run it:\n```\nkamel\
    \ run camel-eventing/Investor.java --logs`\n```\n\nYou will see the following\
    \ log if everything is working correctly.\n```\n[1] 2020-10-02 00:19:19.308 INFO\
    \  [main] RuntimeSupport - Apply ContextCustomizer with id=platform-http and type=org.apache.camel.k.http.PlatformHttpServiceContextCustomizer\n\
    [1] 2020-10-02 00:19:19.335 INFO  [main] VertxPlatformHttpServer - Creating new\
    \ Vert.x instance\n[1] 2020-10-02 00:19:19.685 INFO  [main] ApplicationRuntime\
    \ - Listener org.apache.camel.k.listener.ContextConfigurer@93cf163 executed in\
    \ phase ConfigureContext\n[1] 2020-10-02 00:19:19.806 INFO  [main] KnativeComponent\
    \ - found knative transport: org.apache.camel.component.knative.http.KnativeHttpTransport@1de6932a\
    \ for protocol: http\n[1] 2020-10-02 00:19:20.428 INFO  [main] AbstractCamelContext\
    \ - Apache Camel 3.4.0 (camel-k) is starting\n[1] 2020-10-02 00:19:20.431 INFO\
    \  [main] AbstractCamelContext - StreamCaching is not in use. If using streams\
    \ then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html\n\
    [1] 2020-10-02 00:19:20.456 INFO  [main] JacksonDataFormat - The option autoDiscoverObjectMapper\
    \ is set to false, Camel won't search in the registry\n[1] 2020-10-02 00:19:20.773\
    \ INFO  [vert.x-eventloop-thread-1] VertxPlatformHttpServer - Vert.x HttpServerstarted\
    \ on 0.0.0.0:8080\n[1] 2020-10-02 00:19:20.786 INFO  [main] InternalRouteStartupManager\
    \ - Route: route1 started and consuming from: knative://event/predictor.simple\n\
    [1] 2020-10-02 00:19:20.787 INFO  [main] AbstractCamelContext - Total 1 routes,\
    \ of which 1 are started\n[1] 2020-10-02 00:19:20.788 INFO  [main] AbstractCamelContext\
    \ - Apache Camel 3.4.0 (camel-k) started in 0.359 seconds\n```\nTo exit the log\
    \ view, just click here or hit ctrl+c on the terminal window. The integration\
    \ will keep running on the cluster.\n\n\n#### Loading the Bitcoin live data\n\
    Now, let's go ahead and start taking live data from the Bitcoin market and pushing\
    \ it to the event mesh.\nGo to the text editor on the right, under the folder\
    \ /root/camel-eventing. Right click on the directory and choose New -> File and\
    \ name it `market-source.yaml`.\nCreate the camel route loads Bitcoin market data\
    \ every 10 seconds.   \n\nPaste the following code into the application.\n\n<pre\
    \ class=\"file\" data-filename=\"market-source.yaml\" data-target=\"replace\"\
    >\n- from:\n    uri: \"timer:tick\"\n    parameters:\n      period: 10000\n  \
    \  steps:\n      - to: \"xchange:binance?currencyPair=BTC/USDT&service=marketdata&method=ticker\"\
    \n      - marshal:\n          json: {}\n      - log:\n          message: \"Sending\
    \ BTC/USDT data to the broker: ${body}\"\n      - set-header:\n          constant:\
    \ market.btc.usdt\n          name: CE-Type\n      - to: \"knative:event\"\n</pre>\n\
    \nStart the Camel K application\n\n```\nkamel run camel-eventing/market-source.yaml\
    \ -d camel-jackson`\n```\n\nThe integration will be deployed on the cluster.\n\
    \nAfter successfully deployed, you will be able to see it in the [Developer Console\
    \ Topology](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/camel-knative/graph).\n\
    \nWhen the Bitcoin data start floating into the data, all predictor services and\
    \ the investor service will automatically start up.\n\n![startsup](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step3-01-startsup.png)\n"
  difficulty: basic
  slug: step3
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 3
  type: challenge
- assignment: '## When the market closes...


    Bitcoin market never closes, but closing hours are expected to be present for
    standard markets. We''re going to simulate a closing on the market by stopping
    the source integration.


    When the market closes and updates are no longer pushed into the event mesh, all
    downstream services will scale down to zero. This includes the two prediction
    algorithms, the two services that receive events from the mesh and also the external
    investor service.


    To simulate a market close, we will delete the market-source:


    ```

    kamel delete market-source`

    ```


    To see the other services going down, go to the [Developer Console Topology view](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/camel-knative/graph)
    after two minutes, you will see the pod slowly shutdown.


    ![marketclose](/openshift/assets/middleware/middleware-camelk/camel-k-eventing/Eventing-Step4-01-marketclose.png)


    ## Congratulations


    In this scenario you got to play with Camel K and Serverless - Knative Eventing.
    We use Camel K as a Source to load data into event mesh based on Broker. And create
    couple of functions using Camel K that subscribe to the events in the mesh. There
    are much more to Camel K. Be sure to visit [Camel K](https://camel.apache.org/camel-k/latest/index.html)
    to learn even more about the architecture and capabilities of this exciting new
    framework.

    '
  difficulty: basic
  slug: step4
  tabs:
  - hostname: crc-nonest-1
    title: cli
    type: terminal
  - hostname: crc-nonest-1
    port: '30443'
    title: web-ui
    type: service
  timelimit: '300'
  title: Step 4
  type: challenge
developers:
- btannous@redhat.com
- nvinto@redhat.com
- rjarvine@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner:
- openshift
private: 'false'
published: 'true'
skipping_enabled: 'true'
slug: camel-k-eventing
tags:
- openshift
title: Serverless Eventing with Camel K
type: truck
